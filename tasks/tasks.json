{
  "tasks": [
    {
      "id": 1,
      "title": "Setup Project Structure and Dependencies",
      "description": "Initialize the project repository with proper structure and install required dependencies for the Taiga-Task-Master system.",
      "details": "1. Create a new TypeScript project using Node.js\n2. Initialize with `npm init -y` or `yarn init -y`\n3. Install core dependencies:\n   - TypeScript (^5.1.6)\n   - Express (^4.18.2) for API endpoints\n   - Axios (^1.4.0) for HTTP requests\n   - Zod (^3.21.4) for schema validation\n   - dotenv (^16.3.1) for environment variables\n4. Setup TypeScript configuration:\n```json\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"NodeNext\",\n    \"moduleResolution\": \"NodeNext\",\n    \"esModuleInterop\": true,\n    \"strict\": true,\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\"\n  },\n  \"include\": [\"src/**/*\"]\n}\n```\n5. Create folder structure:\n```\nsrc/\n  modules/\n    webhook-receiver/\n    task-generation/\n    taiga-sync/\n  utils/\n  types/\n  config/\n  index.ts\n```\n6. Setup environment variables template (.env.example):\n```\nTAIGA_API_URL=https://api.taiga.io/api/v1\nTAIGA_AUTH_TOKEN=\nTAIGA_TOKEN_TYPE=Bearer\nPROJECT_SLUG=\n```\n7. Create a basic README.md with project description and setup instructions",
      "testStrategy": "1. Verify project structure is correctly set up\n2. Ensure all dependencies can be installed without errors\n3. Validate TypeScript compilation works\n4. Test environment variable loading\n5. Create a simple smoke test that imports and uses key dependencies",
      "priority": "high",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 2,
      "title": "Implement Core Types and Interfaces",
      "description": "Define TypeScript interfaces and types for the system based on the PRD requirements.",
      "details": "Create a types directory with the following files:\n\n1. `src/types/webhook.ts`:\n```typescript\nexport type WebhookPayload = {\n  project: number;\n  ref: number;\n  content: string;\n};\n```\n\n2. `src/types/auth.ts`:\n```typescript\nexport type AuthConfig = {\n  token: string;\n  tokenType: 'Bearer';\n};\n```\n\n3. `src/types/taiga.ts`:\n```typescript\nexport enum TaskStatus {\n  NEW = 'New',\n  IN_PROGRESS = 'In progress',\n  READY_FOR_TEST = 'Ready for test',\n  CLOSED = 'Closed',\n  NEEDS_INFO = 'Needs info'\n}\n\nexport type TaigaTask = {\n  id: number;\n  ref: number;\n  title: string;\n  description: string;\n  status: string;\n  tags: string[];\n  project: number;\n  swimlane?: number;\n};\n\nexport type TaigaClientDeps = {\n  http: {\n    get: (url: string, config?: any) => Promise<any>;\n    post: (url: string, body: unknown, config?: any) => Promise<any>;\n    patch: (url: string, body: unknown, config?: any) => Promise<any>;\n  };\n  auth: AuthConfig;\n};\n```\n\n4. `src/types/tasks.ts`:\n```typescript\nexport type SubtaskFileContent = {\n  id: number;\n  title: string;\n  description?: string;\n  status: string;\n  details?: string;\n  dependencies?: number[];\n};\n\nexport type TasksFileContent = {\n  tasks: SubtaskFileContent[];\n};\n\nexport type TrackerTask = {\n  masterId: number;\n  title: string;\n  description: string;\n  status: string;\n  details?: string;\n  dependencies: number[];\n};\n```\n\n5. Create schema validation using Zod in `src/utils/validation.ts`:\n```typescript\nimport { z } from 'zod';\nimport { TaskStatus } from '../types/taiga';\n\nexport const webhookPayloadSchema = z.object({\n  project: z.number(),\n  ref: z.number(),\n  content: z.string()\n});\n\nexport const subtaskSchema = z.object({\n  id: z.number().positive(),\n  title: z.string().min(1),\n  description: z.string().optional(),\n  status: z.nativeEnum(TaskStatus),\n  details: z.string().optional(),\n  dependencies: z.array(z.number()).optional().default([])\n});\n\nexport const tasksFileSchema = z.object({\n  tasks: z.array(subtaskSchema)\n});\n\nexport const validateWebhookPayload = (data: unknown) => webhookPayloadSchema.parse(data);\nexport const validateTasksFile = (data: unknown) => tasksFileSchema.parse(data);\n```",
      "testStrategy": "1. Create unit tests for each type definition\n2. Test Zod schema validation with valid and invalid inputs\n3. Verify that type constraints are enforced correctly\n4. Test enum values match expected Taiga task statuses\n5. Ensure optional fields are handled correctly",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 3,
      "title": "Implement Authentication and HTTP Client",
      "description": "Create a reusable HTTP client with Taiga authentication handling and token management.",
      "details": "1. Create `src/utils/http-client.ts`:\n```typescript\nimport axios, { AxiosInstance, AxiosRequestConfig } from 'axios';\nimport { AuthConfig } from '../types/auth';\n\nexport const createHttpClient = (baseURL: string): AxiosInstance => {\n  return axios.create({\n    baseURL,\n    timeout: 10000,\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  });\n};\n```\n\n2. Create `src/utils/auth.ts`:\n```typescript\nimport { AuthConfig } from '../types/auth';\nimport { AxiosInstance } from 'axios';\n\nexport const getAuthHeader = ({token, tokenType}: AuthConfig) => {\n  return {'Authorization': `${tokenType} ${token}`};\n};\n\nexport const refreshToken = async (httpClient: AxiosInstance, currentToken: string): Promise<string> => {\n  try {\n    const response = await httpClient.post('/auth/refresh', {}, {\n      headers: {\n        'Authorization': `Bearer ${currentToken}`\n      }\n    });\n    return response.data.auth_token;\n  } catch (error) {\n    console.error('Failed to refresh token:', error);\n    throw new Error('Token refresh failed');\n  }\n};\n\n// Setup token rotation every hour\nexport const setupTokenRotation = (\n  httpClient: AxiosInstance,\n  initialToken: string,\n  onNewToken: (token: string) => void\n) => {\n  let currentToken = initialToken;\n  \n  // Refresh token every hour\n  const intervalId = setInterval(async () => {\n    try {\n      const newToken = await refreshToken(httpClient, currentToken);\n      currentToken = newToken;\n      onNewToken(newToken);\n    } catch (error) {\n      console.error('Token rotation failed:', error);\n    }\n  }, 60 * 60 * 1000); // 1 hour\n  \n  return () => clearInterval(intervalId); // Return cleanup function\n};\n```\n\n3. Create `src/config/taiga-client.ts`:\n```typescript\nimport { AxiosInstance } from 'axios';\nimport { AuthConfig } from '../types/auth';\nimport { TaigaClientDeps, TaigaTask } from '../types/taiga';\nimport { getAuthHeader } from '../utils/auth';\nimport { createTags } from '../utils/tags';\n\nexport const createTaigaClient = ({http, auth}: TaigaClientDeps) => {\n  const authHeader = getAuthHeader(auth);\n  \n  return {\n    createTask: async (task: Omit<TaigaTask, 'id' | 'ref'> & { masterId: number }): Promise<TaigaTask> => {\n      const { masterId, ...taskData } = task;\n      const response = await http.post('/tasks', {\n        ...taskData,\n        tags: createTags(masterId)\n      }, { headers: authHeader });\n      return response.data;\n    },\n    \n    getTask: async (taskId: number): Promise<TaigaTask> => {\n      const response = await http.get(`/tasks/${taskId}`, { headers: authHeader });\n      return response.data;\n    },\n    \n    updateTask: async (taskId: number, data: Partial<TaigaTask>): Promise<TaigaTask> => {\n      const response = await http.patch(`/tasks/${taskId}`, data, { headers: authHeader });\n      return response.data;\n    },\n    \n    getTasksByTag: async (tag: string): Promise<TaigaTask[]> => {\n      const response = await http.get('/tasks', { \n        headers: authHeader,\n        params: { tags: tag }\n      });\n      return response.data;\n    },\n    \n    createSwimlane: async (projectId: number, name: string): Promise<any> => {\n      const response = await http.post('/swimlanes', {\n        project: projectId,\n        name\n      }, { headers: authHeader });\n      return response.data;\n    },\n    \n    getSwimlanes: async (projectId: number): Promise<any[]> => {\n      const response = await http.get('/swimlanes', {\n        headers: authHeader,\n        params: { project: projectId }\n      });\n      return response.data;\n    }\n  };\n};\n```\n\n4. Create `src/utils/retry.ts` for implementing retry logic:\n```typescript\nexport type RetryOptions = {\n  times: number;\n  delay: 'fixed' | 'exponential';\n  initialDelay?: number;\n  jitter?: boolean;\n};\n\nexport const retry = <T>(\n  fn: () => Promise<T>,\n  options: RetryOptions\n): Promise<T> => {\n  const { times, delay, initialDelay = 1000, jitter = false } = options;\n  \n  return new Promise<T>((resolve, reject) => {\n    const attempt = (attemptNumber: number) => {\n      fn()\n        .then(resolve)\n        .catch((error) => {\n          if (attemptNumber >= times) {\n            reject(error);\n            return;\n          }\n          \n          let nextDelay = initialDelay;\n          if (delay === 'exponential') {\n            nextDelay = initialDelay * Math.pow(2, attemptNumber);\n          }\n          \n          if (jitter) {\n            nextDelay = nextDelay * (0.5 + Math.random());\n          }\n          \n          setTimeout(() => attempt(attemptNumber + 1), nextDelay);\n        });\n    };\n    \n    attempt(0);\n  });\n};\n```",
      "testStrategy": "1. Unit test the HTTP client creation with different base URLs\n2. Test auth header generation with various token configurations\n3. Mock Axios for testing token refresh functionality\n4. Test retry mechanism with both success and failure scenarios\n5. Verify exponential backoff calculations\n6. Test jitter randomization is within expected bounds\n7. Mock Taiga API responses for client method tests",
      "priority": "high",
      "dependencies": [
        1,
        2
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 4,
      "title": "Implement Tag Management System",
      "description": "Create utilities for generating, validating, and extracting information from Taiga task tags according to the PRD specifications.",
      "details": "Create `src/utils/tags.ts` with the following implementation:\n\n```typescript\n// Regular expression for validating taskmaster tags\nconst TASKMASTER_TAG_REGEX = /^taskmaster-(\\d+)$/;\n\n/**\n * Creates the tags array for a task with the given master ID\n * @param taskId The master task ID from the tasks.json file\n * @returns Array of tags for the Taiga task\n */\nexport const createTags = (taskId: number): string[] => [\n  `project-tm:${process.env.PROJECT_SLUG}`,\n  `taskmaster-${taskId}`\n];\n\n/**\n * Extracts the master task ID from a taskmaster tag\n * @param tag The tag to extract from (format: 'taskmaster-123')\n * @returns The extracted ID or null if the tag doesn't match the pattern\n */\nexport const extractMasterIdFromTag = (tag: string): number | null => {\n  const match = tag.match(TASKMASTER_TAG_REGEX);\n  if (!match) return null;\n  \n  const id = parseInt(match[1], 10);\n  return isNaN(id) ? null : id;\n};\n\n/**\n * Finds the taskmaster tag in an array of tags and extracts the ID\n * @param tags Array of tags to search through\n * @returns The master ID or null if not found\n */\nexport const findMasterIdInTags = (tags: string[]): number | null => {\n  for (const tag of tags) {\n    const id = extractMasterIdFromTag(tag);\n    if (id !== null) return id;\n  }\n  return null;\n};\n\n/**\n * Creates the project tag for filtering tasks by project\n * @returns The project tag string\n */\nexport const getProjectTag = (): string => {\n  const projectSlug = process.env.PROJECT_SLUG;\n  if (!projectSlug) {\n    throw new Error('PROJECT_SLUG environment variable is not set');\n  }\n  return `project-tm:${projectSlug}`;\n};\n\n/**\n * Validates if a tag follows the taskmaster tag pattern\n * @param tag The tag to validate\n * @returns True if the tag is a valid taskmaster tag\n */\nexport const isTaskmasterTag = (tag: string): boolean => {\n  return TASKMASTER_TAG_REGEX.test(tag);\n};\n```",
      "testStrategy": "1. Test tag creation with various task IDs\n2. Verify project tag format is correct\n3. Test extraction of master IDs from valid and invalid tags\n4. Test finding master IDs in arrays of mixed tags\n5. Verify validation of taskmaster tags\n6. Test error handling when PROJECT_SLUG is not set\n7. Test with edge cases like very large IDs or special characters in project slugs",
      "priority": "medium",
      "dependencies": [
        2
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 5,
      "title": "Implement PRD Webhook Receiver Module",
      "description": "Create the webhook endpoint that receives PRD updates from Taiga and initiates the task generation process.",
      "details": "Create the webhook receiver module in `src/modules/webhook-receiver/`:\n\n1. Create `src/modules/webhook-receiver/controller.ts`:\n```typescript\nimport { Request, Response } from 'express';\nimport { validateWebhookPayload } from '../../utils/validation';\nimport { WebhookPayload } from '../../types/webhook';\nimport { TaigaTask } from '../../types/taiga';\n\nexport type WebhookControllerDeps = {\n  taigaClient: {\n    getTask: (taskId: number) => Promise<TaigaTask>;\n  };\n  taskGenerator: {\n    generateTasks: (prdContent: string) => Promise<void>;\n  };\n};\n\nexport const createWebhookController = ({ taigaClient, taskGenerator }: WebhookControllerDeps) => {\n  return async (req: Request, res: Response) => {\n    try {\n      // Validate the incoming webhook payload\n      const payload = validateWebhookPayload(req.body) as WebhookPayload;\n      \n      // Get the task details to verify it's in the PRD swimlane\n      const task = await taigaClient.getTask(payload.ref);\n      \n      // Check if the task is in a PRD swimlane (this would need to be configured)\n      // This is a placeholder - actual implementation would check swimlane name or other criteria\n      const isPRD = task.swimlane === parseInt(process.env.PRD_SWIMLANE_ID || '0', 10);\n      \n      if (!isPRD) {\n        return res.status(400).json({ error: 'Task is not in PRD swimlane' });\n      }\n      \n      // Generate tasks from the PRD content\n      await taskGenerator.generateTasks(payload.content);\n      \n      return res.status(200).json({ success: true });\n    } catch (error) {\n      console.error('Webhook processing error:', error);\n      return res.status(500).json({ error: 'Failed to process webhook' });\n    }\n  };\n};\n```\n\n2. Create `src/modules/webhook-receiver/routes.ts`:\n```typescript\nimport { Router } from 'express';\nimport { createWebhookController, WebhookControllerDeps } from './controller';\n\nexport const createWebhookRoutes = (deps: WebhookControllerDeps) => {\n  const router = Router();\n  const controller = createWebhookController(deps);\n  \n  router.post('/api/prd-webhook', controller);\n  \n  return router;\n};\n```\n\n3. Create JWT validation middleware in `src/modules/webhook-receiver/middleware.ts`:\n```typescript\nimport { Request, Response, NextFunction } from 'express';\nimport jwt from 'jsonwebtoken';\n\nexport const validateJWT = (secret: string) => {\n  return (req: Request, res: Response, next: NextFunction) => {\n    const authHeader = req.headers.authorization;\n    \n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n      return res.status(401).json({ error: 'Missing or invalid authorization header' });\n    }\n    \n    const token = authHeader.split(' ')[1];\n    \n    try {\n      jwt.verify(token, secret);\n      next();\n    } catch (error) {\n      return res.status(401).json({ error: 'Invalid token' });\n    }\n  };\n};\n```\n\n4. Install the required JWT package:\n```bash\nnpm install jsonwebtoken\nnpm install @types/jsonwebtoken --save-dev\n```",
      "testStrategy": "1. Test webhook endpoint with valid and invalid payloads\n2. Mock Taiga client to test swimlane validation\n3. Test JWT validation middleware with valid and invalid tokens\n4. Verify error handling for various failure scenarios\n5. Test integration with task generator\n6. Verify correct HTTP status codes are returned\n7. Test handling of edge cases like malformed JSON",
      "priority": "high",
      "dependencies": [
        2,
        3
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 6,
      "title": "Implement Task Generation Service",
      "description": "Create a service that wraps the claude-task-master CLI tool to generate tasks from PRD content.",
      "details": "Create the task generation service in `src/modules/task-generation/`:\n\n1. Create `src/modules/task-generation/service.ts`:\n```typescript\nimport { exec } from 'child_process';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { validateTasksFile } from '../../utils/validation';\nimport { TasksFileContent } from '../../types/tasks';\n\nexport type TaskGeneratorDeps = {\n  tempDir: string;\n  claudeTaskMasterPath: string;\n};\n\nexport const createTaskGenerator = ({ tempDir, claudeTaskMasterPath }: TaskGeneratorDeps) => {\n  return {\n    generateTasks: async (prdContent: string): Promise<TasksFileContent> => {\n      // Create a unique directory for this operation\n      const operationId = Date.now().toString();\n      const operationDir = path.join(tempDir, operationId);\n      \n      await fs.mkdir(operationDir, { recursive: true });\n      \n      try {\n        // Write PRD content to file\n        const prdFilePath = path.join(operationDir, 'prd.txt');\n        await fs.writeFile(prdFilePath, prdContent, 'utf-8');\n        \n        // Define output path\n        const tasksFilePath = path.join(operationDir, 'tasks.json');\n        \n        // Execute claude-task-master CLI\n        await new Promise<void>((resolve, reject) => {\n          exec(\n            `${claudeTaskMasterPath} ${prdFilePath} ${tasksFilePath}`,\n            (error) => {\n              if (error) {\n                reject(new Error(`Failed to execute claude-task-master: ${error.message}`));\n              } else {\n                resolve();\n              }\n            }\n          );\n        });\n        \n        // Read and validate the generated tasks file\n        const tasksFileContent = await fs.readFile(tasksFilePath, 'utf-8');\n        const parsedContent = JSON.parse(tasksFileContent);\n        \n        // Validate the tasks file structure\n        const validatedTasks = validateTasksFile(parsedContent);\n        \n        return validatedTasks;\n      } catch (error) {\n        console.error('Task generation error:', error);\n        throw new Error(`Failed to generate tasks: ${(error as Error).message}`);\n      } finally {\n        // Clean up temporary files\n        try {\n          await fs.rm(operationDir, { recursive: true, force: true });\n        } catch (cleanupError) {\n          console.error('Failed to clean up temporary files:', cleanupError);\n        }\n      }\n    }\n  };\n};\n```\n\n2. Create a file system abstraction for better testability in `src/utils/file-system.ts`:\n```typescript\nimport fs from 'fs/promises';\nimport path from 'path';\n\nexport type FileSystem = {\n  readFile: (path: string, encoding: string) => Promise<string>;\n  writeFile: (path: string, data: string, encoding: string) => Promise<void>;\n  mkdir: (path: string, options?: { recursive?: boolean }) => Promise<void>;\n  rm: (path: string, options?: { recursive?: boolean, force?: boolean }) => Promise<void>;\n};\n\nexport const createFileSystem = (): FileSystem => {\n  return {\n    readFile: (filePath, encoding) => fs.readFile(filePath, encoding),\n    writeFile: (filePath, data, encoding) => fs.writeFile(filePath, data, encoding),\n    mkdir: (dirPath, options) => fs.mkdir(dirPath, options),\n    rm: (dirPath, options) => fs.rm(dirPath, options)\n  };\n};\n```\n\n3. Update the task generator to use the file system abstraction:\n```typescript\nexport type TaskGeneratorDeps = {\n  tempDir: string;\n  claudeTaskMasterPath: string;\n  fileSystem: FileSystem;\n  execCommand: (command: string) => Promise<void>;\n};\n\nexport const createTaskGenerator = ({ tempDir, claudeTaskMasterPath, fileSystem, execCommand }: TaskGeneratorDeps) => {\n  return {\n    generateTasks: async (prdContent: string): Promise<TasksFileContent> => {\n      // Create a unique directory for this operation\n      const operationId = Date.now().toString();\n      const operationDir = path.join(tempDir, operationId);\n      \n      await fileSystem.mkdir(operationDir, { recursive: true });\n      \n      try {\n        // Write PRD content to file\n        const prdFilePath = path.join(operationDir, 'prd.txt');\n        await fileSystem.writeFile(prdFilePath, prdContent, 'utf-8');\n        \n        // Define output path\n        const tasksFilePath = path.join(operationDir, 'tasks.json');\n        \n        // Execute claude-task-master CLI\n        await execCommand(`${claudeTaskMasterPath} ${prdFilePath} ${tasksFilePath}`);\n        \n        // Read and validate the generated tasks file\n        const tasksFileContent = await fileSystem.readFile(tasksFilePath, 'utf-8');\n        const parsedContent = JSON.parse(tasksFileContent);\n        \n        // Validate the tasks file structure\n        const validatedTasks = validateTasksFile(parsedContent);\n        \n        return validatedTasks;\n      } catch (error) {\n        console.error('Task generation error:', error);\n        throw new Error(`Failed to generate tasks: ${(error as Error).message}`);\n      } finally {\n        // Clean up temporary files\n        try {\n          await fileSystem.rm(operationDir, { recursive: true, force: true });\n        } catch (cleanupError) {\n          console.error('Failed to clean up temporary files:', cleanupError);\n        }\n      }\n    }\n  };\n};\n```\n\n4. Create a utility for executing commands in `src/utils/exec.ts`:\n```typescript\nimport { exec } from 'child_process';\n\nexport const execCommand = (command: string): Promise<void> => {\n  return new Promise((resolve, reject) => {\n    exec(command, (error) => {\n      if (error) {\n        reject(new Error(`Command execution failed: ${error.message}`));\n      } else {\n        resolve();\n      }\n    });\n  });\n};\n```",
      "testStrategy": "1. Mock file system operations to test task generation without actual file I/O\n2. Test handling of claude-task-master CLI execution with mocked exec function\n3. Verify proper cleanup of temporary files\n4. Test validation of generated tasks file\n5. Test error handling for various failure scenarios (file write errors, CLI execution errors, validation errors)\n6. Test with various PRD content inputs\n7. Verify atomic transaction behavior",
      "priority": "high",
      "dependencies": [
        2
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 7,
      "title": "Implement Markdown Rendering Engine",
      "description": "Create a service to transform task data into formatted Markdown content for Taiga task descriptions.",
      "details": "Create the Markdown rendering engine in `src/utils/markdown-renderer.ts`:\n\n```typescript\nimport { SubtaskFileContent } from '../types/tasks';\n\n/**\n * Renders a subtask as Markdown content\n * @param subtask The subtask to render\n * @returns Formatted Markdown string\n */\nexport const renderSubtask = (subtask: SubtaskFileContent): string => {\n  let markdown = `### ${subtask.title} [${subtask.status}]\\n`;\n  \n  if (subtask.description) {\n    markdown += `${subtask.description}\\n\\n`;\n  }\n  \n  if (subtask.details) {\n    markdown += `**Details**:\\n${subtask.details}\\n\\n`;\n  }\n  \n  return markdown;\n};\n\n/**\n * Generates a Mermaid diagram showing task dependencies\n * @param tasks Array of tasks with dependencies\n * @param currentTaskId ID of the current task being rendered\n * @returns Mermaid diagram as a Markdown code block\n */\nexport const generateDependencyDiagram = (\n  tasks: SubtaskFileContent[],\n  currentTaskId: number\n): string => {\n  // Create a map of task IDs to titles for easy lookup\n  const taskMap = new Map(tasks.map(task => [task.id, task.title]));\n  \n  // Start the Mermaid graph\n  let diagram = '```mermaid\\ngraph TD;\\n';\n  \n  // Add nodes for all tasks that are either dependencies of the current task\n  // or have the current task as a dependency\n  const relevantTasks = tasks.filter(task => {\n    if (task.id === currentTaskId) return true;\n    if (task.dependencies?.includes(currentTaskId)) return true;\n    if (tasks.find(t => t.id === currentTaskId)?.dependencies?.includes(task.id)) return true;\n    return false;\n  });\n  \n  // Add nodes\n  relevantTasks.forEach(task => {\n    const title = taskMap.get(task.id) || `Task ${task.id}`;\n    // Truncate long titles\n    const shortTitle = title.length > 20 ? title.substring(0, 17) + '...' : title;\n    diagram += `  task${task.id}[\"#${task.id}: ${shortTitle}\"]\\n`;\n  });\n  \n  // Highlight current task\n  diagram += `  style task${currentTaskId} fill:#f9f,stroke:#333,stroke-width:2px\\n`;\n  \n  // Add edges for dependencies\n  relevantTasks.forEach(task => {\n    if (task.dependencies) {\n      task.dependencies.forEach(depId => {\n        if (taskMap.has(depId)) {\n          diagram += `  task${depId} --> task${task.id}\\n`;\n        }\n      });\n    }\n  });\n  \n  diagram += '```';\n  return diagram;\n};\n\n/**\n * Renders a complete task with all its details and dependency diagram\n * @param task The main task to render\n * @param allTasks All tasks in the system (for dependency diagram)\n * @returns Complete Markdown content for the task\n */\nexport const renderTaskMarkdown = (\n  task: SubtaskFileContent,\n  allTasks: SubtaskFileContent[]\n): string => {\n  let markdown = `# ${task.title}\\n\\n`;\n  \n  if (task.description) {\n    markdown += `${task.description}\\n\\n`;\n  }\n  \n  if (task.details) {\n    markdown += `## Implementation Details\\n${task.details}\\n\\n`;\n  }\n  \n  // Add dependency information\n  if (task.dependencies && task.dependencies.length > 0) {\n    markdown += '## Dependencies\\n';\n    markdown += 'This task depends on:\\n\\n';\n    \n    task.dependencies.forEach(depId => {\n      const depTask = allTasks.find(t => t.id === depId);\n      if (depTask) {\n        markdown += `- #${depId}: ${depTask.title}\\n`;\n      } else {\n        markdown += `- #${depId} (Unknown task)\\n`;\n      }\n    });\n    \n    markdown += '\\n';\n  }\n  \n  // Add dependency diagram\n  markdown += '## Dependency Diagram\\n';\n  markdown += generateDependencyDiagram(allTasks, task.id);\n  \n  return markdown;\n};\n```",
      "testStrategy": "1. Test rendering of subtasks with various combinations of optional fields\n2. Verify dependency diagram generation with different dependency structures\n3. Test handling of missing tasks in dependency references\n4. Verify complete task rendering with all components\n5. Test with edge cases like very long titles or descriptions\n6. Verify Mermaid syntax is correctly generated\n7. Test with tasks that have no dependencies",
      "priority": "medium",
      "dependencies": [
        2
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 8,
      "title": "Implement Taiga Synchronizer Module",
      "description": "Create a service that synchronizes generated tasks with Taiga, handling creation, updates, and conflict resolution.",
      "details": "Create the Taiga synchronizer module in `src/modules/taiga-sync/`:\n\n1. Create `src/modules/taiga-sync/service.ts`:\n```typescript\nimport { TaigaTask } from '../../types/taiga';\nimport { SubtaskFileContent, TasksFileContent, TrackerTask } from '../../types/tasks';\nimport { findMasterIdInTags, getProjectTag } from '../../utils/tags';\nimport { renderTaskMarkdown } from '../../utils/markdown-renderer';\nimport { retry } from '../../utils/retry';\nimport fs from 'fs/promises';\nimport path from 'path';\n\n// Chunk utility for batch processing\nconst chunk = <T>(array: T[], size: number): T[][] => {\n  return Array.from(\n    { length: Math.ceil(array.length / size) },\n    (_, i) => array.slice(i * size, i * size + size)\n  );\n};\n\n// Sequential execution utility\nconst sequential = <T>(fns: (() => Promise<T>)[]): Promise<T[]> => {\n  return fns.reduce(\n    (promise, fn) => promise.then(results => fn().then(result => [...results, result])),\n    Promise.resolve<T[]>([])\n  );\n};\n\nexport type TaigaSyncDeps = {\n  taigaClient: {\n    createTask: (task: any) => Promise<TaigaTask>;\n    getTask: (taskId: number) => Promise<TaigaTask>;\n    updateTask: (taskId: number, data: any) => Promise<TaigaTask>;\n    getTasksByTag: (tag: string) => Promise<TaigaTask[]>;\n    createSwimlane: (projectId: number, name: string) => Promise<any>;\n    getSwimlanes: (projectId: number) => Promise<any[]>;\n  };\n  fileSystem: {\n    writeFile: (path: string, data: string, encoding: string) => Promise<void>;\n    mkdir: (path: string, options?: { recursive?: boolean }) => Promise<void>;\n  };\n  failuresDir: string;\n};\n\nexport const createTaigaSynchronizer = ({ taigaClient, fileSystem, failuresDir }: TaigaSyncDeps) => {\n  // Ensure failures directory exists\n  fileSystem.mkdir(failuresDir, { recursive: true }).catch(err => {\n    console.error('Failed to create failures directory:', err);\n  });\n  \n  // Convert file content tasks to tracker tasks\n  const mapToTrackerTasks = (tasksFile: TasksFileContent): TrackerTask[] => {\n    return tasksFile.tasks.map(task => ({\n      masterId: task.id,\n      title: task.title,\n      description: task.description || '',\n      status: task.status,\n      details: task.details,\n      dependencies: task.dependencies || []\n    }));\n  };\n  \n  // Find existing Taiga task by master ID\n  const findExistingTask = async (masterId: number): Promise<TaigaTask | null> => {\n    try {\n      const tasks = await taigaClient.getTasksByTag(`taskmaster-${masterId}`);\n      return tasks.length > 0 ? tasks[0] : null;\n    } catch (error) {\n      console.error(`Failed to find existing task for master ID ${masterId}:`, error);\n      return null;\n    }\n  };\n  \n  // Get or create the Master Managed swimlane\n  const getMasterManagedSwimlane = async (projectId: number): Promise<number> => {\n    try {\n      const swimlanes = await taigaClient.getSwimlanes(projectId);\n      const masterSwimlane = swimlanes.find(s => s.name === 'Master Managed');\n      \n      if (masterSwimlane) {\n        return masterSwimlane.id;\n      }\n      \n      // Create the swimlane if it doesn't exist\n      const newSwimlane = await taigaClient.createSwimlane(projectId, 'Master Managed');\n      return newSwimlane.id;\n    } catch (error) {\n      console.error('Failed to get or create Master Managed swimlane:', error);\n      throw error;\n    }\n  };\n  \n  // Process a single task\n  const processTask = async (task: TrackerTask, allTasks: SubtaskFileContent[], projectId: number, swimlaneId: number): Promise<void> => {\n    try {\n      // Find if task already exists\n      const existingTask = await findExistingTask(task.masterId);\n      \n      // Generate markdown content\n      const markdownContent = renderTaskMarkdown(\n        allTasks.find(t => t.id === task.masterId) as SubtaskFileContent,\n        allTasks\n      );\n      \n      if (existingTask) {\n        // Update existing task\n        await taigaClient.updateTask(existingTask.id, {\n          subject: task.title,\n          description: markdownContent,\n          status: task.status\n        });\n      } else {\n        // Create new task\n        await taigaClient.createTask({\n          project: projectId,\n          subject: task.title,\n          description: markdownContent,\n          status: task.status,\n          swimlane: swimlaneId,\n          masterId: task.masterId\n        });\n      }\n    } catch (error) {\n      console.error(`Failed to process task ${task.masterId}:`, error);\n      \n      // Save failed task to dead letter queue\n      const failureFile = path.join(failuresDir, `task-${task.masterId}-${Date.now()}.json`);\n      await fileSystem.writeFile(\n        failureFile,\n        JSON.stringify(task, null, 2),\n        'utf-8'\n      );\n      \n      throw error;\n    }\n  };\n  \n  // Process a batch of tasks\n  const processBatch = async (tasks: TrackerTask[], allTasks: SubtaskFileContent[], projectId: number, swimlaneId: number): Promise<void> => {\n    await Promise.all(\n      tasks.map(task =>\n        retry(\n          () => processTask(task, allTasks, projectId, swimlaneId),\n          { times: 3, delay: 'exponential', initialDelay: 1000, jitter: true }\n        ).catch(error => {\n          console.error(`Failed to process task ${task.masterId} after retries:`, error);\n        })\n      )\n    );\n  };\n  \n  return {\n    syncTasks: async (tasksFile: TasksFileContent, projectId: number): Promise<void> => {\n      // Convert file tasks to tracker tasks\n      const trackerTasks = mapToTrackerTasks(tasksFile);\n      \n      // Get or create the Master Managed swimlane\n      const swimlaneId = await getMasterManagedSwimlane(projectId);\n      \n      // Process tasks in batches to avoid API rate limits\n      const batches = chunk(trackerTasks, 10);\n      \n      await sequential(\n        batches.map(batch => () => processBatch(batch, tasksFile.tasks, projectId, swimlaneId))\n      );\n    }\n  };\n};\n```\n\n2. Create `src/modules/taiga-sync/index.ts` for easier importing:\n```typescript\nexport { createTaigaSynchronizer } from './service';\n```",
      "testStrategy": "1. Test task mapping from file content to tracker tasks\n2. Mock Taiga client to test finding existing tasks\n3. Test swimlane management (getting and creating)\n4. Verify batch processing with different batch sizes\n5. Test retry mechanism for failed operations\n6. Verify dead letter queue functionality for persistently failing tasks\n7. Test full synchronization workflow with various scenarios (new tasks, existing tasks, mixed)\n8. Test handling of API rate limits\n9. Verify conflict resolution strategy",
      "priority": "high",
      "dependencies": [
        3,
        4,
        6,
        7
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 9,
      "title": "Implement Error Handling and Logging System",
      "description": "Create a robust error handling and logging system to track and manage failures throughout the application.",
      "details": "Create a comprehensive error handling and logging system:\n\n1. Create `src/utils/logger.ts`:\n```typescript\nimport winston from 'winston';\n\n// Define log levels\nconst levels = {\n  error: 0,\n  warn: 1,\n  info: 2,\n  http: 3,\n  debug: 4,\n};\n\n// Define level based on environment\nconst level = () => {\n  const env = process.env.NODE_ENV || 'development';\n  return env === 'development' ? 'debug' : 'info';\n};\n\n// Define colors for each level\nconst colors = {\n  error: 'red',\n  warn: 'yellow',\n  info: 'green',\n  http: 'magenta',\n  debug: 'white',\n};\n\n// Add colors to winston\nwinston.addColors(colors);\n\n// Define format for console output\nconst consoleFormat = winston.format.combine(\n  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss:ms' }),\n  winston.format.colorize({ all: true }),\n  winston.format.printf(\n    (info) => `${info.timestamp} ${info.level}: ${info.message}`,\n  ),\n);\n\n// Define format for file output\nconst fileFormat = winston.format.combine(\n  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss:ms' }),\n  winston.format.json(),\n);\n\n// Define transports\nconst transports = [\n  // Console transport\n  new winston.transports.Console({\n    format: consoleFormat,\n  }),\n  // Error log file transport\n  new winston.transports.File({\n    filename: 'logs/error.log',\n    level: 'error',\n    format: fileFormat,\n  }),\n  // All logs file transport\n  new winston.transports.File({\n    filename: 'logs/all.log',\n    format: fileFormat,\n  }),\n];\n\n// Create the logger\nexport const logger = winston.createLogger({\n  level: level(),\n  levels,\n  transports,\n});\n```\n\n2. Create `src/utils/error-handler.ts`:\n```typescript\nimport { logger } from './logger';\n\nexport enum ErrorCode {\n  VALIDATION_ERROR = 'VALIDATION_ERROR',\n  API_ERROR = 'API_ERROR',\n  TASK_GENERATION_ERROR = 'TASK_GENERATION_ERROR',\n  SYNC_ERROR = 'SYNC_ERROR',\n  AUTHENTICATION_ERROR = 'AUTHENTICATION_ERROR',\n  UNKNOWN_ERROR = 'UNKNOWN_ERROR'\n}\n\nexport class AppError extends Error {\n  code: ErrorCode;\n  details?: any;\n  \n  constructor(message: string, code: ErrorCode, details?: any) {\n    super(message);\n    this.name = 'AppError';\n    this.code = code;\n    this.details = details;\n    \n    // Capture stack trace\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nexport const handleError = (error: Error | AppError): void => {\n  if (error instanceof AppError) {\n    logger.error(`[${error.code}] ${error.message}`, { \n      stack: error.stack,\n      details: error.details \n    });\n  } else {\n    logger.error(`[${ErrorCode.UNKNOWN_ERROR}] ${error.message}`, { \n      stack: error.stack \n    });\n  }\n};\n\n// Global unhandled rejection handler\nexport const setupGlobalErrorHandlers = (): void => {\n  process.on('uncaughtException', (error) => {\n    handleError(error);\n    // Give logger time to write before exiting\n    setTimeout(() => process.exit(1), 500);\n  });\n  \n  process.on('unhandledRejection', (reason) => {\n    const error = reason instanceof Error \n      ? reason \n      : new AppError(\n          `Unhandled rejection: ${reason}`,\n          ErrorCode.UNKNOWN_ERROR,\n          { reason }\n        );\n    \n    handleError(error);\n  });\n};\n```\n\n3. Create a dead letter queue handler in `src/utils/dead-letter-queue.ts`:\n```typescript\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { logger } from './logger';\n\nexport type DeadLetterQueueDeps = {\n  baseDir: string;\n  fileSystem: {\n    writeFile: (path: string, data: string, encoding: string) => Promise<void>;\n    mkdir: (path: string, options?: { recursive?: boolean }) => Promise<void>;\n  };\n};\n\nexport const createDeadLetterQueue = ({ baseDir, fileSystem }: DeadLetterQueueDeps) => {\n  // Ensure the directory exists\n  fileSystem.mkdir(baseDir, { recursive: true }).catch(err => {\n    logger.error('Failed to create dead letter queue directory', { error: err });\n  });\n  \n  return {\n    /**\n     * Save a failed item to the dead letter queue\n     * @param type Type of item (e.g., 'task', 'webhook')\n     * @param id Identifier for the item\n     * @param data The data that failed to process\n     * @param error The error that occurred\n     */\n    saveFailedItem: async <T>(type: string, id: string | number, data: T, error: Error): Promise<void> => {\n      const timestamp = Date.now();\n      const filename = `${type}-${id}-${timestamp}.json`;\n      const filePath = path.join(baseDir, filename);\n      \n      const content = {\n        type,\n        id,\n        timestamp,\n        data,\n        error: {\n          message: error.message,\n          stack: error.stack,\n          name: error.name\n        }\n      };\n      \n      try {\n        await fileSystem.writeFile(filePath, JSON.stringify(content, null, 2), 'utf-8');\n        logger.info(`Saved failed ${type} to dead letter queue: ${filename}`);\n      } catch (writeError) {\n        logger.error('Failed to write to dead letter queue', { \n          originalError: error,\n          writeError,\n          data\n        });\n      }\n    }\n  };\n};\n```\n\n4. Install the required winston package:\n```bash\nnpm install winston\n```",
      "testStrategy": "1. Test logger with different log levels and message types\n2. Verify log files are created with correct formats\n3. Test AppError class with various error codes and details\n4. Verify global error handlers catch unhandled exceptions and rejections\n5. Test dead letter queue with different item types and error scenarios\n6. Verify error details are properly captured and formatted\n7. Test integration with other modules to ensure errors are properly logged",
      "priority": "medium",
      "dependencies": [
        1
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 10,
      "title": "Implement Configuration Management",
      "description": "Create a centralized configuration system to manage environment variables and application settings.",
      "details": "Create a configuration management system:\n\n1. Create `src/config/index.ts`:\n```typescript\nimport dotenv from 'dotenv';\nimport path from 'path';\nimport { z } from 'zod';\nimport { logger } from '../utils/logger';\n\n// Load environment variables from .env file\ndotenv.config();\n\n// Define configuration schema\nconst configSchema = z.object({\n  // Server configuration\n  PORT: z.string().transform(val => parseInt(val, 10)).default('3000'),\n  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),\n  \n  // Taiga API configuration\n  TAIGA_API_URL: z.string().url(),\n  TAIGA_AUTH_TOKEN: z.string().min(1),\n  TAIGA_TOKEN_TYPE: z.literal('Bearer').default('Bearer'),\n  \n  // Project configuration\n  PROJECT_ID: z.string().transform(val => parseInt(val, 10)),\n  PROJECT_SLUG: z.string().min(1),\n  PRD_SWIMLANE_ID: z.string().transform(val => parseInt(val, 10)).optional(),\n  \n  // Webhook configuration\n  WEBHOOK_SECRET: z.string().min(1),\n  \n  // Task generation configuration\n  CLAUDE_TASK_MASTER_PATH: z.string().min(1),\n  TEMP_DIR: z.string().default(path.join(process.cwd(), 'temp')),\n  \n  // Error handling configuration\n  FAILURES_DIR: z.string().default(path.join(process.cwd(), 'sync-failures')),\n  LOGS_DIR: z.string().default(path.join(process.cwd(), 'logs'))\n});\n\n// Parse and validate configuration\nconst parseConfig = () => {\n  try {\n    return configSchema.parse(process.env);\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      const missingVars = error.errors\n        .filter(err => err.code === 'invalid_type' && err.received === 'undefined')\n        .map(err => err.path.join('.'));\n      \n      if (missingVars.length > 0) {\n        console.error(`Missing required environment variables: ${missingVars.join(', ')}`);\n      } else {\n        console.error('Configuration validation failed:', error.errors);\n      }\n    } else {\n      console.error('Failed to parse configuration:', error);\n    }\n    \n    process.exit(1);\n  }\n};\n\n// Export the validated configuration\nexport const config = parseConfig();\n\n// Log configuration on startup (excluding sensitive values)\nexport const logConfig = () => {\n  const sanitizedConfig = { ...config };\n  \n  // Remove sensitive values\n  delete sanitizedConfig.TAIGA_AUTH_TOKEN;\n  delete sanitizedConfig.WEBHOOK_SECRET;\n  \n  logger.info('Application configuration:', sanitizedConfig);\n};\n```\n\n2. Create a configuration loader for tests in `src/config/test-config.ts`:\n```typescript\nimport { config as appConfig } from '.';\n\n// Default test configuration\nexport const testConfig = {\n  ...appConfig,\n  NODE_ENV: 'test',\n  TEMP_DIR: '/tmp/taiga-task-master-test/temp',\n  FAILURES_DIR: '/tmp/taiga-task-master-test/failures',\n  LOGS_DIR: '/tmp/taiga-task-master-test/logs'\n};\n\n// Helper to override config for tests\nexport const createTestConfig = (overrides: Partial<typeof appConfig>) => {\n  return {\n    ...testConfig,\n    ...overrides\n  };\n};\n```",
      "testStrategy": "1. Test configuration validation with valid and invalid environment variables\n2. Verify default values are applied correctly\n3. Test type transformations (string to number)\n4. Verify error handling for missing required variables\n5. Test configuration overrides for test environment\n6. Verify sensitive values are properly sanitized in logs\n7. Test with various environment configurations",
      "priority": "medium",
      "dependencies": [
        1
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 11,
      "title": "Implement Application Server",
      "description": "Create the main Express application server that integrates all modules and handles HTTP requests.",
      "details": "Create the main application server:\n\n1. Create `src/app.ts`:\n```typescript\nimport express from 'express';\nimport cors from 'cors';\nimport helmet from 'helmet';\nimport { createWebhookRoutes } from './modules/webhook-receiver/routes';\nimport { validateJWT } from './modules/webhook-receiver/middleware';\nimport { logger } from './utils/logger';\nimport { config } from './config';\n\nexport type AppDeps = {\n  webhookController: {\n    taigaClient: any;\n    taskGenerator: any;\n  };\n};\n\nexport const createApp = ({ webhookController }: AppDeps) => {\n  const app = express();\n  \n  // Middleware\n  app.use(helmet()); // Security headers\n  app.use(cors()); // CORS handling\n  app.use(express.json()); // Parse JSON bodies\n  \n  // Request logging\n  app.use((req, res, next) => {\n    logger.http(`${req.method} ${req.url}`);\n    next();\n  });\n  \n  // Health check endpoint\n  app.get('/health', (req, res) => {\n    res.status(200).json({ status: 'ok' });\n  });\n  \n  // Webhook routes with JWT validation\n  app.use(\n    '/api',\n    validateJWT(config.WEBHOOK_SECRET),\n    createWebhookRoutes(webhookController)\n  );\n  \n  // 404 handler\n  app.use((req, res) => {\n    res.status(404).json({ error: 'Not found' });\n  });\n  \n  // Error handler\n  app.use((err: any, req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.error('Express error handler:', { error: err });\n    \n    res.status(err.status || 500).json({\n      error: {\n        message: err.message || 'Internal server error',\n        code: err.code || 'UNKNOWN_ERROR'\n      }\n    });\n  });\n  \n  return app;\n};\n```\n\n2. Create `src/index.ts` as the application entry point:\n```typescript\nimport { createApp } from './app';\nimport { config, logConfig } from './config';\nimport { logger } from './utils/logger';\nimport { setupGlobalErrorHandlers } from './utils/error-handler';\nimport { createHttpClient } from './utils/http-client';\nimport { createTaigaClient } from './config/taiga-client';\nimport { createTaskGenerator } from './modules/task-generation/service';\nimport { createFileSystem } from './utils/file-system';\nimport { execCommand } from './utils/exec';\n\n// Setup global error handlers\nsetupGlobalErrorHandlers();\n\n// Log application configuration\nlogConfig();\n\n// Create dependencies\nconst httpClient = createHttpClient(config.TAIGA_API_URL);\nconst fileSystem = createFileSystem();\n\nconst taigaClient = createTaigaClient({\n  http: httpClient,\n  auth: {\n    token: config.TAIGA_AUTH_TOKEN,\n    tokenType: config.TAIGA_TOKEN_TYPE\n  }\n});\n\nconst taskGenerator = createTaskGenerator({\n  tempDir: config.TEMP_DIR,\n  claudeTaskMasterPath: config.CLAUDE_TASK_MASTER_PATH,\n  fileSystem,\n  execCommand\n});\n\n// Create and start the application\nconst app = createApp({\n  webhookController: {\n    taigaClient,\n    taskGenerator\n  }\n});\n\nconst server = app.listen(config.PORT, () => {\n  logger.info(`Server running on port ${config.PORT} in ${config.NODE_ENV} mode`);\n});\n\n// Handle graceful shutdown\nconst shutdown = () => {\n  logger.info('Shutting down server...');\n  server.close(() => {\n    logger.info('Server closed');\n    process.exit(0);\n  });\n  \n  // Force close after 10 seconds\n  setTimeout(() => {\n    logger.error('Forced shutdown after timeout');\n    process.exit(1);\n  }, 10000);\n};\n\nprocess.on('SIGTERM', shutdown);\nprocess.on('SIGINT', shutdown);\n```\n\n3. Install the required packages:\n```bash\nnpm install express cors helmet\nnpm install @types/express @types/cors --save-dev\n```",
      "testStrategy": "1. Test application setup with various dependency configurations\n2. Verify middleware is correctly applied\n3. Test health check endpoint\n4. Verify JWT validation middleware is applied to API routes\n5. Test 404 handler for non-existent routes\n6. Test error handler with various error types\n7. Verify graceful shutdown behavior\n8. Test CORS and security headers",
      "priority": "high",
      "dependencies": [
        3,
        5,
        9,
        10
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 12,
      "title": "Implement CLI Interface",
      "description": "Create a command-line interface for manual task generation and synchronization.",
      "details": "Create a CLI interface for manual operations:\n\n1. Create `src/cli/index.ts`:\n```typescript\nimport { Command } from 'commander';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { config } from '../config';\nimport { createHttpClient } from '../utils/http-client';\nimport { createTaigaClient } from '../config/taiga-client';\nimport { createTaskGenerator } from '../modules/task-generation/service';\nimport { createTaigaSynchronizer } from '../modules/taiga-sync/service';\nimport { createFileSystem } from '../utils/file-system';\nimport { execCommand } from '../utils/exec';\nimport { logger } from '../utils/logger';\n\nconst program = new Command();\n\n// Setup dependencies\nconst httpClient = createHttpClient(config.TAIGA_API_URL);\nconst fileSystem = createFileSystem();\n\nconst taigaClient = createTaigaClient({\n  http: httpClient,\n  auth: {\n    token: config.TAIGA_AUTH_TOKEN,\n    tokenType: config.TAIGA_TOKEN_TYPE\n  }\n});\n\nconst taskGenerator = createTaskGenerator({\n  tempDir: config.TEMP_DIR,\n  claudeTaskMasterPath: config.CLAUDE_TASK_MASTER_PATH,\n  fileSystem,\n  execCommand\n});\n\nconst taigaSynchronizer = createTaigaSynchronizer({\n  taigaClient,\n  fileSystem,\n  failuresDir: config.FAILURES_DIR\n});\n\n// Setup CLI commands\nprogram\n  .name('taiga-task-master')\n  .description('CLI for Taiga Task Master')\n  .version('1.0.0');\n\n// Generate tasks command\nprogram\n  .command('generate')\n  .description('Generate tasks from a PRD file')\n  .argument('<prdFile>', 'Path to the PRD file')\n  .option('-o, --output <outputFile>', 'Output file path', 'tasks.json')\n  .action(async (prdFile, options) => {\n    try {\n      logger.info(`Generating tasks from ${prdFile}`);\n      \n      // Read PRD file\n      const prdContent = await fs.readFile(path.resolve(prdFile), 'utf-8');\n      \n      // Generate tasks\n      const tasks = await taskGenerator.generateTasks(prdContent);\n      \n      // Write to output file\n      await fs.writeFile(path.resolve(options.output), JSON.stringify(tasks, null, 2), 'utf-8');\n      \n      logger.info(`Tasks generated and saved to ${options.output}`);\n    } catch (error) {\n      logger.error('Failed to generate tasks:', { error });\n      process.exit(1);\n    }\n  });\n\n// Sync tasks command\nprogram\n  .command('sync')\n  .description('Sync tasks with Taiga')\n  .argument('<tasksFile>', 'Path to the tasks JSON file')\n  .option('-p, --project <projectId>', 'Taiga project ID', config.PROJECT_ID.toString())\n  .action(async (tasksFile, options) => {\n    try {\n      logger.info(`Syncing tasks from ${tasksFile} to project ${options.project}`);\n      \n      // Read tasks file\n      const tasksContent = await fs.readFile(path.resolve(tasksFile), 'utf-8');\n      const tasks = JSON.parse(tasksContent);\n      \n      // Sync tasks\n      await taigaSynchronizer.syncTasks(tasks, parseInt(options.project, 10));\n      \n      logger.info('Tasks synced successfully');\n    } catch (error) {\n      logger.error('Failed to sync tasks:', { error });\n      process.exit(1);\n    }\n  });\n\n// Parse arguments and execute\nprogram.parse();\n```\n\n2. Create a script entry in `package.json`:\n```json\n{\n  \"scripts\": {\n    \"cli\": \"ts-node src/cli/index.ts\"\n  }\n}\n```\n\n3. Install the required package:\n```bash\nnpm install commander\n```",
      "testStrategy": "1. Test CLI command parsing with various arguments\n2. Verify file reading and writing operations\n3. Test task generation with sample PRD files\n4. Test task synchronization with sample tasks files\n5. Verify error handling for invalid inputs\n6. Test with missing or invalid arguments\n7. Verify integration with task generator and synchronizer modules",
      "priority": "low",
      "dependencies": [
        6,
        8,
        10
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 13,
      "title": "Implement Unit and Integration Tests",
      "description": "Create comprehensive test suite for all modules and components of the system.",
      "details": "Set up a comprehensive testing framework:\n\n1. Create `jest.config.js`:\n```javascript\nmodule.exports = {\n  preset: 'ts-jest',\n  testEnvironment: 'node',\n  roots: ['<rootDir>/src'],\n  testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],\n  transform: {\n    '^.+\\\\.ts$': 'ts-jest'\n  },\n  collectCoverage: true,\n  coverageDirectory: 'coverage',\n  collectCoverageFrom: [\n    'src/**/*.ts',\n    '!src/**/*.d.ts',\n    '!src/**/__tests__/**'\n  ],\n  coverageThreshold: {\n    global: {\n      branches: 80,\n      functions: 80,\n      lines: 80,\n      statements: 80\n    }\n  }\n};\n```\n\n2. Create test utilities in `src/utils/__tests__/test-utils.ts`:\n```typescript\nimport { TaigaTask } from '../../types/taiga';\nimport { SubtaskFileContent, TasksFileContent } from '../../types/tasks';\n\n// Mock file system\nexport const createMockFileSystem = () => ({\n  readFile: jest.fn().mockResolvedValue(''),\n  writeFile: jest.fn().mockResolvedValue(undefined),\n  mkdir: jest.fn().mockResolvedValue(undefined),\n  rm: jest.fn().mockResolvedValue(undefined)\n});\n\n// Mock HTTP client\nexport const createMockHttpClient = () => ({\n  get: jest.fn().mockResolvedValue({ data: {} }),\n  post: jest.fn().mockResolvedValue({ data: {} }),\n  patch: jest.fn().mockResolvedValue({ data: {} })\n});\n\n// Mock exec command\nexport const createMockExecCommand = () => jest.fn().mockResolvedValue(undefined);\n\n// Sample tasks for testing\nexport const createSampleTasks = (): TasksFileContent => ({\n  tasks: [\n    {\n      id: 1,\n      title: 'Task 1',\n      description: 'Description 1',\n      status: 'New',\n      details: 'Details 1',\n      dependencies: []\n    },\n    {\n      id: 2,\n      title: 'Task 2',\n      description: 'Description 2',\n      status: 'In progress',\n      details: 'Details 2',\n      dependencies: [1]\n    },\n    {\n      id: 3,\n      title: 'Task 3',\n      description: 'Description 3',\n      status: 'Ready for test',\n      details: 'Details 3',\n      dependencies: [1, 2]\n    }\n  ]\n});\n\n// Sample Taiga tasks for testing\nexport const createSampleTaigaTasks = (): TaigaTask[] => [\n  {\n    id: 101,\n    ref: 1,\n    title: 'Task 1',\n    description: 'Description 1',\n    status: 'New',\n    tags: ['project-tm:test-project', 'taskmaster-1'],\n    project: 1\n  },\n  {\n    id: 102,\n    ref: 2,\n    title: 'Task 2',\n    description: 'Description 2',\n    status: 'In progress',\n    tags: ['project-tm:test-project', 'taskmaster-2'],\n    project: 1\n  }\n];\n```\n\n3. Create sample tests for key modules:\n\n`src/utils/__tests__/tags.test.ts`:\n```typescript\nimport { createTags, extractMasterIdFromTag, findMasterIdInTags, isTaskmasterTag } from '../tags';\n\ndescribe('Tag utilities', () => {\n  beforeEach(() => {\n    process.env.PROJECT_SLUG = 'test-project';\n  });\n  \n  afterEach(() => {\n    delete process.env.PROJECT_SLUG;\n  });\n  \n  test('createTags should generate correct tag array', () => {\n    const tags = createTags(123);\n    expect(tags).toEqual(['project-tm:test-project', 'taskmaster-123']);\n  });\n  \n  test('extractMasterIdFromTag should extract ID from valid tag', () => {\n    const id = extractMasterIdFromTag('taskmaster-456');\n    expect(id).toBe(456);\n  });\n  \n  test('extractMasterIdFromTag should return null for invalid tag', () => {\n    const id = extractMasterIdFromTag('invalid-tag');\n    expect(id).toBeNull();\n  });\n  \n  test('findMasterIdInTags should find ID in array of tags', () => {\n    const tags = ['tag1', 'taskmaster-789', 'tag2'];\n    const id = findMasterIdInTags(tags);\n    expect(id).toBe(789);\n  });\n  \n  test('findMasterIdInTags should return null if no matching tag', () => {\n    const tags = ['tag1', 'tag2', 'tag3'];\n    const id = findMasterIdInTags(tags);\n    expect(id).toBeNull();\n  });\n  \n  test('isTaskmasterTag should validate tags correctly', () => {\n    expect(isTaskmasterTag('taskmaster-123')).toBe(true);\n    expect(isTaskmasterTag('taskmaster-')).toBe(false);\n    expect(isTaskmasterTag('taskmaster-abc')).toBe(false);\n    expect(isTaskmasterTag('other-tag')).toBe(false);\n  });\n});\n```\n\n`src/modules/task-generation/__tests__/service.test.ts`:\n```typescript\nimport { createTaskGenerator } from '../service';\nimport { createMockFileSystem, createMockExecCommand } from '../../../utils/__tests__/test-utils';\n\ndescribe('Task Generator Service', () => {\n  const mockFileSystem = createMockFileSystem();\n  const mockExecCommand = createMockExecCommand();\n  \n  const taskGenerator = createTaskGenerator({\n    tempDir: '/tmp/test',\n    claudeTaskMasterPath: '/usr/bin/claude-task-master',\n    fileSystem: mockFileSystem,\n    execCommand: mockExecCommand\n  });\n  \n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n  \n  test('generateTasks should create directory and files', async () => {\n    // Mock file read to return valid JSON\n    mockFileSystem.readFile.mockResolvedValueOnce(JSON.stringify({\n      tasks: [\n        { id: 1, title: 'Task 1', description: 'Desc 1', status: 'New' }\n      ]\n    }));\n    \n    await taskGenerator.generateTasks('PRD content');\n    \n    // Check directory was created\n    expect(mockFileSystem.mkdir).toHaveBeenCalled();\n    \n    // Check PRD was written\n    expect(mockFileSystem.writeFile).toHaveBeenCalledWith(\n      expect.stringContaining('/prd.txt'),\n      'PRD content',\n      'utf-8'\n    );\n    \n    // Check CLI was executed\n    expect(mockExecCommand).toHaveBeenCalled();\n    \n    // Check cleanup was attempted\n    expect(mockFileSystem.rm).toHaveBeenCalled();\n  });\n  \n  test('generateTasks should handle CLI execution errors', async () => {\n    mockExecCommand.mockRejectedValueOnce(new Error('CLI error'));\n    \n    await expect(taskGenerator.generateTasks('PRD content')).rejects.toThrow('Failed to generate tasks');\n    \n    // Check cleanup was still attempted\n    expect(mockFileSystem.rm).toHaveBeenCalled();\n  });\n});\n```\n\n4. Install testing packages:\n```bash\nnpm install jest ts-jest @types/jest --save-dev\n```\n\n5. Add test scripts to `package.json`:\n```json\n{\n  \"scripts\": {\n    \"test\": \"jest\",\n    \"test:watch\": \"jest --watch\",\n    \"test:coverage\": \"jest --coverage\"\n  }\n}\n```",
      "testStrategy": "1. Create unit tests for all utility functions\n2. Test each module in isolation with mocked dependencies\n3. Create integration tests for key workflows\n4. Test error handling and edge cases\n5. Verify code coverage meets thresholds\n6. Test with both valid and invalid inputs\n7. Create end-to-end tests for complete workflows\n8. Test performance with large datasets",
      "priority": "medium",
      "dependencies": [
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 14,
      "title": "Implement Docker Containerization",
      "description": "Create Docker configuration for containerized deployment of the application.",
      "details": "Set up Docker containerization:\n\n1. Create `Dockerfile`:\n```dockerfile\n# Use Node.js LTS as base image\nFROM node:18-alpine\n\n# Set working directory\nWORKDIR /app\n\n# Install dependencies for claude-task-master (assuming it's a Python tool)\nRUN apk add --no-cache python3 py3-pip\n\n# Install claude-task-master (replace with actual installation method)\nRUN pip3 install claude-task-master\n\n# Copy package files\nCOPY package*.json ./\n\n# Install dependencies\nRUN npm ci --only=production\n\n# Copy application code\nCOPY dist/ ./dist/\n\n# Create directories for data persistence\nRUN mkdir -p /app/temp /app/sync-failures /app/logs\n\n# Expose port\nEXPOSE 3000\n\n# Set environment variables\nENV NODE_ENV=production \\\n    TEMP_DIR=/app/temp \\\n    FAILURES_DIR=/app/sync-failures \\\n    LOGS_DIR=/app/logs \\\n    CLAUDE_TASK_MASTER_PATH=claude-task-master\n\n# Run the application\nCMD [\"node\", \"dist/index.js\"]\n```\n\n2. Create `.dockerignore`:\n```\nnode_modules\nnpm-debug.log\nyarn-debug.log\nyarn-error.log\n.git\n.github\n.vscode\ncoverage\ntemp\nsync-failures\nlogs\n.env\n.env.*\n```\n\n3. Create `docker-compose.yml`:\n```yaml\nversion: '3.8'\n\nservices:\n  app:\n    build: .\n    ports:\n      - \"3000:3000\"\n    environment:\n      - NODE_ENV=production\n      - PORT=3000\n      - TAIGA_API_URL=${TAIGA_API_URL}\n      - TAIGA_AUTH_TOKEN=${TAIGA_AUTH_TOKEN}\n      - TAIGA_TOKEN_TYPE=${TAIGA_TOKEN_TYPE}\n      - PROJECT_ID=${PROJECT_ID}\n      - PROJECT_SLUG=${PROJECT_SLUG}\n      - PRD_SWIMLANE_ID=${PRD_SWIMLANE_ID}\n      - WEBHOOK_SECRET=${WEBHOOK_SECRET}\n    volumes:\n      - app-temp:/app/temp\n      - app-failures:/app/sync-failures\n      - app-logs:/app/logs\n    restart: unless-stopped\n\nvolumes:\n  app-temp:\n  app-failures:\n  app-logs:\n```\n\n4. Create build scripts in `package.json`:\n```json\n{\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"docker:build\": \"npm run build && docker build -t taiga-task-master .\",\n    \"docker:run\": \"docker run -p 3000:3000 --env-file .env taiga-task-master\"\n  }\n}\n```\n\n5. Create `.dockerignore`:\n```\nnode_modules\nnpm-debug.log\nyarn-debug.log\nyarn-error.log\n.git\n.github\n.vscode\ncoverage\ntemp\nsync-failures\nlogs\n.env\n.env.*\n```",
      "testStrategy": "1. Verify Docker image builds successfully\n2. Test container startup with various environment configurations\n3. Verify volume mounting for persistent data\n4. Test container restart behavior\n5. Verify application functionality within container\n6. Test with docker-compose\n7. Verify logs are correctly written to mounted volumes\n8. Test container resource usage under load",
      "priority": "low",
      "dependencies": [
        11
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 15,
      "title": "Create Documentation and Deployment Guide",
      "description": "Create comprehensive documentation for the system, including setup, usage, and deployment instructions.",
      "details": "Create comprehensive documentation:\n\n1. Create `README.md`:\n```markdown\n# Taiga-Task-Master System\n\nAn automated system for converting Product Requirement Documents (PRDs) into tracked Taiga tasks with nested subtasks, using a tag-based identification system and atomic Markdown rendering.\n\n## Features\n\n- Webhook receiver for PRD updates from Taiga\n- Automated task generation from PRD content\n- Synchronization with Taiga tasks\n- Tag-based task identification\n- Markdown rendering with dependency visualization\n- CLI for manual operations\n\n## Architecture\n\nThe system consists of three main modules:\n\n1. **PRD Webhook Receiver**: Receives PRD updates from Taiga\n2. **Task Generation Service**: Generates tasks from PRD content\n3. **Taiga Synchronizer**: Synchronizes tasks with Taiga\n\n## Installation\n\n### Prerequisites\n\n- Node.js 18 or higher\n- Python 3.8 or higher (for claude-task-master)\n- Taiga instance with API access\n\n### Using npm\n\n```bash\n# Clone the repository\ngit clone https://github.com/your-org/taiga-task-master.git\ncd taiga-task-master\n\n# Install dependencies\nnpm install\n\n# Build the application\nnpm run build\n```\n\n### Using Docker\n\n```bash\n# Clone the repository\ngit clone https://github.com/your-org/taiga-task-master.git\ncd taiga-task-master\n\n# Build Docker image\nnpm run docker:build\n\n# Run with Docker Compose\ndocker-compose up -d\n```\n\n## Configuration\n\nCreate a `.env` file in the root directory with the following variables:\n\n```env\n# Server configuration\nPORT=3000\nNODE_ENV=production\n\n# Taiga API configuration\nTAIGA_API_URL=https://api.taiga.io/api/v1\nTAIGA_AUTH_TOKEN=your-auth-token\nTAIGA_TOKEN_TYPE=Bearer\n\n# Project configuration\nPROJECT_ID=12345\nPROJECT_SLUG=your-project-slug\nPRD_SWIMLANE_ID=67890\n\n# Webhook configuration\nWEBHOOK_SECRET=your-webhook-secret\n\n# Task generation configuration\nCLAUDE_TASK_MASTER_PATH=/path/to/claude-task-master\n```\n\n## Usage\n\n### Running the Server\n\n```bash\nnpm start\n```\n\n### Using the CLI\n\n```bash\n# Generate tasks from a PRD file\nnpm run cli -- generate path/to/prd.txt -o tasks.json\n\n# Sync tasks with Taiga\nnpm run cli -- sync tasks.json -p 12345\n```\n\n## API Endpoints\n\n### POST /api/prd-webhook\n\nReceives PRD updates from Taiga and initiates task generation.\n\n**Headers:**\n- `Authorization: Bearer <jwt-token>`\n\n**Request Body:**\n```json\n{\n  \"project\": 12345,\n  \"ref\": 67890,\n  \"content\": \"PRD content...\"\n}\n```\n\n## Development\n\n```bash\n# Run in development mode\nnpm run dev\n\n# Run tests\nnpm test\n\n# Run tests with coverage\nnpm run test:coverage\n```\n\n## License\n\nMIT\n```\n\n2. Create `DEPLOYMENT.md`:\n```markdown\n# Deployment Guide\n\nThis guide provides instructions for deploying the Taiga-Task-Master system in various environments.\n\n## Prerequisites\n\n- Node.js 18 or higher\n- Python 3.8 or higher (for claude-task-master)\n- Taiga instance with API access\n- Docker and Docker Compose (for containerized deployment)\n\n## Environment Variables\n\nThe following environment variables are required for deployment:\n\n| Variable | Description | Example |\n|----------|-------------|--------|\n| PORT | Server port | 3000 |\n| NODE_ENV | Environment (development/production) | production |\n| TAIGA_API_URL | Taiga API URL | https://api.taiga.io/api/v1 |\n| TAIGA_AUTH_TOKEN | Taiga authentication token | your-auth-token |\n| TAIGA_TOKEN_TYPE | Token type | Bearer |\n| PROJECT_ID | Taiga project ID | 12345 |\n| PROJECT_SLUG | Taiga project slug | your-project-slug |\n| PRD_SWIMLANE_ID | ID of the PRD swimlane | 67890 |\n| WEBHOOK_SECRET | Secret for JWT validation | your-webhook-secret |\n| CLAUDE_TASK_MASTER_PATH | Path to claude-task-master | /usr/bin/claude-task-master |\n\n## Deployment Options\n\n### Docker Deployment\n\n1. Build the Docker image:\n   ```bash\n   npm run docker:build\n   ```\n\n2. Create a `.env` file with the required environment variables.\n\n3. Run with Docker Compose:\n   ```bash\n   docker-compose up -d\n   ```\n\n### Manual Deployment\n\n1. Clone the repository:\n   ```bash\n   git clone https://github.com/your-org/taiga-task-master.git\n   cd taiga-task-master\n   ```\n\n2. Install dependencies:\n   ```bash\n   npm install\n   ```\n\n3. Build the application:\n   ```bash\n   npm run build\n   ```\n\n4. Create a `.env` file with the required environment variables.\n\n5. Start the application:\n   ```bash\n   npm start\n   ```\n\n### Deployment with PM2\n\n1. Install PM2:\n   ```bash\n   npm install -g pm2\n   ```\n\n2. Create a PM2 ecosystem file (`ecosystem.config.js`):\n   ```javascript\n   module.exports = {\n     apps: [{\n       name: 'taiga-task-master',\n       script: 'dist/index.js',\n       instances: 1,\n       autorestart: true,\n       watch: false,\n       max_memory_restart: '1G',\n       env: {\n         NODE_ENV: 'production',\n         // Other environment variables can be set here or in .env file\n       }\n     }]\n   };\n   ```\n\n3. Start with PM2:\n   ```bash\n   pm2 start ecosystem.config.js\n   ```\n\n## Taiga Configuration\n\n### Webhook Setup\n\n1. In your Taiga project, go to Admin > Integrations > Webhooks.\n2. Create a new webhook with the following settings:\n   - Name: PRD Webhook\n   - URL: https://your-server.com/api/prd-webhook\n   - Secret: (same as WEBHOOK_SECRET environment variable)\n   - Events: Task created, Task modified\n\n### Swimlane Setup\n\n1. In your Taiga project, go to Admin > Attributes > Swimlanes.\n2. Create a new swimlane named \"PRD\" for PRD tasks.\n3. Create a new swimlane named \"Master Managed\" for generated tasks.\n4. Note the ID of the PRD swimlane and set it as PRD_SWIMLANE_ID environment variable.\n\n## Monitoring and Maintenance\n\n### Logs\n\nLogs are stored in the following locations:\n\n- All logs: `logs/all.log`\n- Error logs: `logs/error.log`\n\nIn Docker deployment, logs are stored in mounted volumes.\n\n### Failed Tasks\n\nFailed task synchronizations are stored in the `sync-failures/` directory for later inspection and retry.\n\n### Health Check\n\nA health check endpoint is available at `/health` to verify the service is running.\n```\n\n3. Create `API.md`:\n```markdown\n# API Documentation\n\nThis document describes the API endpoints provided by the Taiga-Task-Master system.\n\n## Authentication\n\nAll API endpoints require JWT authentication using the `Authorization` header:\n\n```\nAuthorization: Bearer <jwt-token>\n```\n\nThe JWT token should be signed with the secret specified in the `WEBHOOK_SECRET` environment variable.\n\n## Endpoints\n\n### Health Check\n\n```\nGET /health\n```\n\nReturns the health status of the service.\n\n**Response:**\n```json\n{\n  \"status\": \"ok\"\n}\n```\n\n### PRD Webhook\n\n```\nPOST /api/prd-webhook\n```\n\nReceives PRD updates from Taiga and initiates task generation.\n\n**Headers:**\n- `Authorization: Bearer <jwt-token>`\n- `Content-Type: application/json`\n\n**Request Body:**\n```json\n{\n  \"project\": 12345,\n  \"ref\": 67890,\n  \"content\": \"PRD content...\"\n}\n```\n\n**Response (Success):**\n```json\n{\n  \"success\": true\n}\n```\n\n**Response (Error):**\n```json\n{\n  \"error\": \"Error message\"\n}\n```\n\n## Error Codes\n\nThe API may return the following error codes:\n\n| Code | Description |\n|------|-------------|\n| 400 | Bad Request - Invalid payload or task not in PRD swimlane |\n| 401 | Unauthorized - Missing or invalid JWT token |\n| 404 | Not Found - Endpoint not found |\n| 500 | Internal Server Error - Server-side error |\n\n## Rate Limiting\n\nThe API implements rate limiting to prevent abuse. The limits are as follows:\n\n- 100 requests per minute for GET endpoints\n- 30 requests per minute for POST endpoints\n\nWhen rate limits are exceeded, the API will return a 429 Too Many Requests response.\n```",
      "testStrategy": "1. Verify README contains all required sections\n2. Check deployment guide for completeness\n3. Verify API documentation accuracy\n4. Test documentation with users unfamiliar with the system\n5. Verify all environment variables are documented\n6. Check for broken links or references\n7. Verify code examples are correct and up-to-date\n8. Test deployment following the documented steps",
      "priority": "medium",
      "dependencies": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14
      ],
      "status": "pending",
      "subtasks": []
    }
  ]
}