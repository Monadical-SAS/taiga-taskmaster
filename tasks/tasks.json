{
  "tasks": [
    {
      "id": 1,
      "title": "Create Package Structure and Configuration",
      "description": "Set up the initial worker package structure with proper dependencies, TypeScript configuration, and testing framework.",
      "details": "1. Create a new package directory `packages/worker/`\n2. Initialize package.json with dependencies:\n   - @taiga-task-master/worker-interface\n   - @taiga-task-master/core\n   - simple-git\n   - effect\n   - vitest (dev dependency)\n3. Configure TypeScript:\n```typescript\n// tsconfig.json\n{\n  \"extends\": \"../../tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\"\n  },\n  \"include\": [\"src/**/*\"],\n  \"references\": [\n    { \"path\": \"../worker-interface\" },\n    { \"path\": \"../core\" }\n  ]\n}\n```\n4. Set up directory structure as specified in the PRD\n5. Create initial README.md with package description",
      "testStrategy": "Verify package structure is correct with all required directories. Ensure package.json has correct dependencies. Validate TypeScript configuration by running a test build.",
      "priority": "high",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 2,
      "title": "Extract Core Types and Interfaces",
      "description": "Define and extract common types and interfaces needed across the worker package implementation.",
      "details": "Create `src/core/types.ts` with the following:\n\n```typescript\nimport { TasksMachine } from '@taiga-task-master/core';\nimport { NonEmptyString } from '@taiga-task-master/worker-interface';\nimport { Option } from 'effect';\n\n// Task ID and Task from core package\nexport type { TaskId, Task } from '@taiga-task-master/core';\nexport type { Tasks } from '@taiga-task-master/core';\n\n// Worker result type\nexport type WorkerResult = {\n  success: boolean;\n  artifacts?: string[];\n  error?: Error;\n};\n\n// Next task function type\nexport type NextTaskF = (tasks: TasksMachine.Tasks) => Option<[TasksMachine.TaskId, TasksMachine.Task]>;\n\n// Git operations interface\nexport interface GitOperations {\n  isClean(): Promise<boolean>;\n  branch(name: NonEmptyString): Promise<NonEmptyString>;\n  commitAndPush(): Promise<void>;\n  cleanup(previousBranch: NonEmptyString): Promise<void>;\n  verifyBranchChain?(): Promise<any>;\n  dumpFullState?(label: string): Promise<void>;\n}\n\n// Logger interface\nexport interface Logger {\n  debug(message: string, ...args: any[]): void;\n  info(message: string, ...args: any[]): void;\n  warn(message: string, ...args: any[]): void;\n  error(message: string, ...args: any[]): void;\n}\n\n// Configuration interfaces\nexport interface BaseWorkerConfig {\n  workingDirectory: string;\n  logLevel?: 'debug' | 'info' | 'warn' | 'error';\n  git?: {\n    userConfig?: { name: string; email: string };\n    isolation?: boolean;\n  };\n  timeouts?: {\n    process?: number;\n    hard?: number;\n  };\n}\n\nexport interface GooseWorkerConfig extends BaseWorkerConfig {\n  goose: {\n    model: string;\n    provider: string;\n    instructionsFile?: string;\n  };\n  apiKeys?: {\n    openrouter?: string;\n  };\n}\n\nexport interface TestingWorkerConfig extends BaseWorkerConfig {\n  mockFailures?: boolean;\n  mockDelay?: number;\n}\n```",
      "testStrategy": "Write unit tests to verify type definitions are correct and compatible with the worker-interface and core packages. Test type compatibility by creating mock objects that implement these interfaces.",
      "priority": "high",
      "dependencies": [1],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 3,
      "title": "Implement Git Operations Module",
      "description": "Extract and implement the Git operations module from the integration tests, providing repository management functionality.",
      "details": "Create `src/core/git-operations.ts` with the following implementation:\n\n```typescript\nimport { NonEmptyString, castNonEmptyString } from '@taiga-task-master/worker-interface';\nimport { GitOperations } from './types';\nimport simpleGit, { SimpleGit } from 'simple-git';\nimport { cyrb53 } from '../utils/hash';\n\nexport interface GitConfig {\n  userConfig?: { name: string; email: string };\n  isolation?: boolean;\n}\n\nexport const createBranchName = (task: NonEmptyString): NonEmptyString => {\n  const hash = cyrb53(task);\n  return castNonEmptyString(`task-${hash.toString()}`);\n};\n\nexport const createGitDeps = (config: GitConfig = {}, workingDirectory: string): GitOperations => {\n  const git: SimpleGit = simpleGit({\n    baseDir: workingDirectory,\n    config: [\n      ...(config.userConfig ? [\n        `user.name=${config.userConfig.name}`,\n        `user.email=${config.userConfig.email}`\n      ] : [])\n    ]\n  });\n  \n  let currentBranch: NonEmptyString | null = null;\n  \n  return {\n    async isClean(): Promise<boolean> {\n      const status = await git.status();\n      return status.isClean();\n    },\n    \n    async branch(name: NonEmptyString): Promise<NonEmptyString> {\n      // Store current branch for potential cleanup\n      const status = await git.status();\n      currentBranch = castNonEmptyString(status.current);\n      \n      // Create and checkout new branch\n      const branchName = createBranchName(name);\n      await git.checkoutLocalBranch(branchName);\n      \n      return branchName;\n    },\n    \n    async commitAndPush(): Promise<void> {\n      const status = await git.status();\n      \n      if (status.files.length === 0) {\n        // No changes to commit\n        return;\n      }\n      \n      // Add all changes\n      await git.add('.');\n      \n      // Commit changes\n      await git.commit('Task completed');\n      \n      // Push if not in isolation mode\n      if (!config.isolation) {\n        try {\n          await git.push('origin', status.current, ['--set-upstream']);\n        } catch (error) {\n          // Handle push errors\n          console.error('Failed to push changes:', error);\n          throw error;\n        }\n      }\n    },\n    \n    async cleanup(previousBranch: NonEmptyString): Promise<void> {\n      try {\n        // Discard any uncommitted changes\n        await git.reset(['--hard']);\n        \n        // Checkout previous branch\n        await git.checkout(previousBranch);\n        \n        // Delete the task branch if it exists and we're not in the branch\n        const status = await git.status();\n        if (status.current !== currentBranch) {\n          const branches = await git.branchLocal();\n          if (branches.all.includes(String(currentBranch))) {\n            await git.deleteLocalBranch(String(currentBranch), true);\n          }\n        }\n      } catch (error) {\n        console.error('Failed to cleanup git state:', error);\n        // Still attempt to checkout previous branch even if other cleanup fails\n        await git.checkout(previousBranch);\n      }\n    },\n    \n    async verifyBranchChain(): Promise<any> {\n      const branches = await git.branchLocal();\n      const logs = await git.log();\n      \n      return {\n        branches: branches.all,\n        currentBranch: branches.current,\n        latestCommit: logs.latest,\n        totalCommits: logs.total\n      };\n    },\n    \n    async dumpFullState(label: string): Promise<void> {\n      const status = await git.status();\n      const branches = await git.branchLocal();\n      \n      console.log(`=== GIT STATE [${label}] ===`);\n      console.log('Current branch:', status.current);\n      console.log('Is clean:', status.isClean());\n      console.log('Modified files:', status.modified);\n      console.log('Created files:', status.created);\n      console.log('Deleted files:', status.deleted);\n      console.log('All branches:', branches.all);\n      console.log('========================');\n    }\n  };\n};\n\n// Also create a utility hash function in src/utils/hash.ts\nexport const cyrb53 = (str: string, seed = 0): number => {\n  let h1 = 0xdeadbeef ^ seed;\n  let h2 = 0x41c6ce57 ^ seed;\n  \n  for (let i = 0, ch; i < str.length; i++) {\n    ch = str.charCodeAt(i);\n    h1 = Math.imul(h1 ^ ch, 2654435761);\n    h2 = Math.imul(h2 ^ ch, 1597334677);\n  }\n  \n  h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507);\n  h1 ^= Math.imul(h2 ^ (h2 >>> 13), 3266489909);\n  h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507);\n  h2 ^= Math.imul(h1 ^ (h1 >>> 13), 3266489909);\n  \n  return 4294967296 * (2097151 & h2) + (h1 >>> 0);\n};\n```",
      "testStrategy": "Write unit tests for the Git operations module:\n1. Test branch creation with valid task descriptions\n2. Test isClean detection with mock repository states\n3. Test commitAndPush with simulated file changes\n4. Test cleanup functionality with various branch states\n5. Test error handling during Git operations\n\nUse a temporary directory with an initialized Git repository for integration tests.",
      "priority": "high",
      "dependencies": [2],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 4,
      "title": "Implement Logging and Utilities",
      "description": "Create structured logging and common utility functions needed by the worker implementation.",
      "details": "Create `src/core/logging.ts` with structured logger implementation:\n\n```typescript\nimport { Logger } from './types';\n\nexport const createStructuredLogger = (level: 'debug' | 'info' | 'warn' | 'error' = 'info'): Logger => {\n  const levels = {\n    debug: 0,\n    info: 1,\n    warn: 2,\n    error: 3\n  };\n  \n  const shouldLog = (messageLevel: keyof typeof levels) => {\n    return levels[messageLevel] >= levels[level];\n  };\n  \n  return {\n    debug(message: string, ...args: any[]) {\n      if (shouldLog('debug')) {\n        console.debug(`[DEBUG] ${message}`, ...args);\n      }\n    },\n    \n    info(message: string, ...args: any[]) {\n      if (shouldLog('info')) {\n        console.info(`[INFO] ${message}`, ...args);\n      }\n    },\n    \n    warn(message: string, ...args: any[]) {\n      if (shouldLog('warn')) {\n        console.warn(`[WARN] ${message}`, ...args);\n      }\n    },\n    \n    error(message: string, ...args: any[]) {\n      if (shouldLog('error')) {\n        console.error(`[ERROR] ${message}`, ...args);\n      }\n    }\n  };\n};\n```\n\nCreate `src/utils/sleep.ts` for timeout utilities:\n\n```typescript\nexport const sleep = (ms: number, options?: { signal?: AbortSignal }): Promise<void> => {\n  return new Promise((resolve, reject) => {\n    const timeout = setTimeout(resolve, ms);\n    \n    if (options?.signal) {\n      // Handle abort signal\n      if (options.signal.aborted) {\n        clearTimeout(timeout);\n        reject(new Error('Sleep aborted'));\n      }\n      \n      options.signal.addEventListener('abort', () => {\n        clearTimeout(timeout);\n        reject(new Error('Sleep aborted'));\n      }, { once: true });\n    }\n  });\n};\n```",
      "testStrategy": "Write unit tests for the logging module:\n1. Test each log level with various message types\n2. Verify log filtering based on configured level\n3. Test structured output format\n\nWrite unit tests for sleep utility:\n1. Test basic sleep functionality with timing verification\n2. Test abort signal handling during sleep\n3. Test immediate abort behavior",
      "priority": "medium",
      "dependencies": [2],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 5,
      "title": "Implement NextTask Strategy Functions",
      "description": "Create the NextTask strategy functions that determine which task to execute next from the TasksMachine state.",
      "details": "Create `src/core/next-task.ts` with the following implementation:\n\n```typescript\nimport { TasksMachine } from '@taiga-task-master/core';\nimport { Option } from 'effect';\nimport { NextTaskF } from './types';\n\nexport const createNextTaskStrategies = () => ({\n  /**\n   * Simple FIFO (First-In-First-Out) strategy for task selection\n   * Selects the first available task from the task map\n   */\n  fifo: ((tasks: TasksMachine.Tasks) => {\n    const entries = TasksMachine.Tasks.toEntries(tasks);\n    return entries.length > 0 ? Option.some(entries[0]) : Option.none();\n  }) as NextTaskF,\n  \n  /**\n   * Priority-based task selection strategy\n   * Selects tasks based on priority metadata if available\n   */\n  priority: ((tasks: TasksMachine.Tasks) => {\n    const entries = TasksMachine.Tasks.toEntries(tasks);\n    if (entries.length === 0) return Option.none();\n    \n    // Sort entries by priority if available\n    const sortedEntries = [...entries].sort((a, b) => {\n      const aPriority = a[1].metadata?.priority;\n      const bPriority = b[1].metadata?.priority;\n      \n      // Priority mapping (higher number = higher priority)\n      const priorityMap: Record<string, number> = {\n        high: 3,\n        medium: 2,\n        low: 1\n      };\n      \n      // Default to medium priority if not specified\n      const aPriorityValue = aPriority ? priorityMap[aPriority] || 2 : 2;\n      const bPriorityValue = bPriority ? priorityMap[bPriority] || 2 : 2;\n      \n      // Sort by priority (descending)\n      return bPriorityValue - aPriorityValue;\n    });\n    \n    return Option.some(sortedEntries[0]);\n  }) as NextTaskF,\n  \n  /**\n   * Dependency-aware task selection strategy\n   * Selects tasks with no unresolved dependencies first\n   */\n  dependencies: ((tasks: TasksMachine.Tasks, completedTaskIds: Set<string> = new Set()) => {\n    const entries = TasksMachine.Tasks.toEntries(tasks);\n    if (entries.length === 0) return Option.none();\n    \n    // Find tasks with no unresolved dependencies\n    const availableTasks = entries.filter(([_, task]) => {\n      const dependencies = task.metadata?.dependencies || [];\n      return dependencies.every(depId => completedTaskIds.has(depId));\n    });\n    \n    if (availableTasks.length === 0) return Option.none();\n    \n    // Sort available tasks by priority\n    const sortedTasks = [...availableTasks].sort((a, b) => {\n      const aPriority = a[1].metadata?.priority;\n      const bPriority = b[1].metadata?.priority;\n      \n      const priorityMap: Record<string, number> = {\n        high: 3,\n        medium: 2,\n        low: 1\n      };\n      \n      const aPriorityValue = aPriority ? priorityMap[aPriority] || 2 : 2;\n      const bPriorityValue = bPriority ? priorityMap[bPriority] || 2 : 2;\n      \n      return bPriorityValue - aPriorityValue;\n    });\n    \n    return Option.some(sortedTasks[0]);\n  }) as NextTaskF\n});\n```",
      "testStrategy": "Write unit tests for NextTask strategies:\n1. Test FIFO strategy with various task collections\n2. Test priority strategy with mixed priority tasks\n3. Test dependency strategy with complex dependency chains\n4. Test edge cases like empty task collections\n5. Verify correct task selection order for each strategy",
      "priority": "high",
      "dependencies": [2],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 6,
      "title": "Implement Task Description Functions",
      "description": "Create functions that convert Task objects to string descriptions for workers to process.",
      "details": "Create `src/core/task-description.ts` with the following implementation:\n\n```typescript\nimport { TasksMachine } from '@taiga-task-master/core';\nimport { NonEmptyString, castNonEmptyString } from '@taiga-task-master/worker-interface';\n\nexport const createTaskDescriptionFunctions = () => ({\n  /**\n   * Simple string extraction for basic task descriptions\n   * Used primarily for testing\n   */\n  simple: (task: TasksMachine.Task): NonEmptyString => {\n    // Extract description directly if available\n    if (typeof task.description === 'string' && task.description.trim() !== '') {\n      return castNonEmptyString(task.description);\n    }\n    \n    // Fallback to stringifying the task\n    return castNonEmptyString(JSON.stringify(task));\n  },\n  \n  /**\n   * Detailed description extraction for production use\n   * Formats task with title, context, and requirements\n   */\n  detailed: (task: TasksMachine.Task): NonEmptyString => {\n    let description = '';\n    \n    // Add title if available\n    if (task.title) {\n      description += `# ${task.title}\\n\\n`;\n    }\n    \n    // Add description\n    if (task.description) {\n      description += `${task.description}\\n\\n`;\n    }\n    \n    // Add context if available\n    if (task.context) {\n      description += `## Context\\n${task.context}\\n\\n`;\n    }\n    \n    // Add requirements if available\n    if (task.requirements) {\n      description += `## Requirements\\n${task.requirements}\\n\\n`;\n    }\n    \n    // Add metadata if available\n    if (task.metadata && Object.keys(task.metadata).length > 0) {\n      description += `## Metadata\\n`;\n      for (const [key, value] of Object.entries(task.metadata)) {\n        if (key !== 'dependencies') { // Skip dependencies in description\n          description += `- ${key}: ${JSON.stringify(value)}\\n`;\n        }\n      }\n    }\n    \n    // Ensure description is not empty\n    if (description.trim() === '') {\n      description = JSON.stringify(task);\n    }\n    \n    return castNonEmptyString(description);\n  },\n  \n  /**\n   * Instruction-focused description for AI workers\n   * Formats task as clear instructions with context\n   */\n  instructions: (task: TasksMachine.Task): NonEmptyString => {\n    let description = '';\n    \n    // Add clear instruction header\n    description += `# Task Instructions\\n\\n`;\n    \n    // Add title as main instruction\n    if (task.title) {\n      description += `## Objective\\n${task.title}\\n\\n`;\n    }\n    \n    // Add detailed description\n    if (task.description) {\n      description += `## Description\\n${task.description}\\n\\n`;\n    }\n    \n    // Add context if available\n    if (task.context) {\n      description += `## Context\\n${task.context}\\n\\n`;\n    }\n    \n    // Add specific requirements\n    if (task.requirements) {\n      description += `## Requirements\\n${task.requirements}\\n\\n`;\n    } else {\n      description += `## Requirements\\n- Complete the task as described\\n- Create or modify files as needed\\n- Ensure code is well-formatted and documented\\n\\n`;\n    }\n    \n    // Add expected deliverables\n    description += `## Deliverables\\n- Modified or created files that fulfill the requirements\\n- Brief explanation of changes made\\n\\n`;\n    \n    // Ensure description is not empty\n    if (description.trim() === '') {\n      description = `# Task Instructions\\n\\nComplete the following task:\\n\\n${JSON.stringify(task)}`;\n    }\n    \n    return castNonEmptyString(description);\n  }\n});\n```",
      "testStrategy": "Write unit tests for task description functions:\n1. Test simple description extraction with various task objects\n2. Test detailed description formatting with complete task metadata\n3. Test instruction formatting for AI workers\n4. Test edge cases like minimal task objects\n5. Verify non-empty string casting works correctly",
      "priority": "medium",
      "dependencies": [2],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 7,
      "title": "Implement Goose AI Worker",
      "description": "Create the Goose AI worker implementation that executes tasks using the Goose CLI.",
      "details": "Create `src/workers/goose.ts` with the following implementation:\n\n```typescript\nimport { WorkerResult, GooseWorkerConfig } from '../core/types';\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { sleep } from '../utils/sleep';\n\nconst execAsync = promisify(exec);\n\nexport const makeGooseWorker = (config: GooseWorkerConfig) => {\n  const {\n    workingDirectory,\n    goose,\n    timeouts = { process: 30000, hard: 35000 },\n    apiKeys = {}\n  } = config;\n  \n  return async (task: { description: string }, options?: { signal?: AbortSignal }): Promise<WorkerResult> => {\n    // Create instructions file\n    const instructionsFile = goose.instructionsFile || path.join(workingDirectory, 'instructions.md');\n    await fs.writeFile(instructionsFile, task.description, 'utf-8');\n    \n    // Prepare environment variables for API keys\n    const env = { ...process.env };\n    if (apiKeys.openrouter) {\n      env.OPENROUTER_API_KEY = apiKeys.openrouter;\n    }\n    \n    // Prepare Goose command\n    const gooseCommand = `goose run --model ${goose.model} --provider ${goose.provider} ${instructionsFile}`;\n    \n    try {\n      // Create abort controller for timeout\n      const abortController = new AbortController();\n      const { signal } = abortController;\n      \n      // Set timeout\n      const timeout = setTimeout(() => {\n        abortController.abort('Goose execution timed out');\n      }, timeouts.hard || 35000);\n      \n      // Execute Goose command with timeout\n      const { stdout, stderr } = await execAsync(gooseCommand, {\n        cwd: workingDirectory,\n        env,\n        signal,\n        timeout: timeouts.process || 30000\n      });\n      \n      // Clear timeout\n      clearTimeout(timeout);\n      \n      // Check for execution errors\n      if (stderr && stderr.includes('Error')) {\n        throw new Error(`Goose execution failed: ${stderr}`);\n      }\n      \n      // Get list of modified files\n      const status = await execAsync('git status --porcelain', { cwd: workingDirectory });\n      const modifiedFiles = status.stdout\n        .split('\\n')\n        .filter(line => line.trim() !== '')\n        .map(line => line.substring(3).trim());\n      \n      return {\n        success: true,\n        artifacts: modifiedFiles\n      };\n    } catch (error: any) {\n      // Handle timeout errors\n      if (error.name === 'AbortError' || (error.signal === 'SIGTERM' && error.killed)) {\n        console.error('Goose execution timed out');\n        \n        // Create fallback file to indicate timeout\n        await fs.writeFile(\n          path.join(workingDirectory, 'timeout-error.md'),\n          `# Task Execution Timed Out\\n\\nThe Goose AI worker timed out while processing the following task:\\n\\n${task.description}`,\n          'utf-8'\n        );\n        \n        return {\n          success: false,\n          artifacts: ['timeout-error.md'],\n          error: new Error('Goose execution timed out')\n        };\n      }\n      \n      // Handle other execution errors\n      console.error('Goose execution failed:', error);\n      \n      // Create error file\n      await fs.writeFile(\n        path.join(workingDirectory, 'execution-error.md'),\n        `# Task Execution Failed\\n\\nError: ${error.message}\\n\\nTask: ${task.description}`,\n        'utf-8'\n      );\n      \n      return {\n        success: false,\n        artifacts: ['execution-error.md'],\n        error\n      };\n    }\n  };\n};\n```",
      "testStrategy": "Write integration tests for the Goose worker:\n1. Test successful task execution with mock Goose CLI\n2. Test timeout handling with deliberately slow tasks\n3. Test error handling with failing Goose commands\n4. Test artifact collection from modified files\n5. Verify proper cleanup after execution\n\nUse mocked Goose CLI for unit tests to avoid actual API calls.",
      "priority": "high",
      "dependencies": [2, 4],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 8,
      "title": "Implement FileSystem Worker Mock for Testing",
      "description": "Create a filesystem-based worker mock for testing Git functionality without expensive Goose calls.",
      "details": "Create `src/testing/filesystem-mock.ts` with the following implementation:\n\n```typescript\nimport { WorkerResult, TestingWorkerConfig } from '../core/types';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { sleep } from '../utils/sleep';\n\nexport const makeFileSystemWorker = (config: TestingWorkerConfig) => {\n  const {\n    workingDirectory,\n    mockFailures = false,\n    mockDelay = 100\n  } = config;\n  \n  return async (task: { description: string }, options?: { signal?: AbortSignal }): Promise<WorkerResult> => {\n    // Simulate processing delay\n    if (mockDelay > 0) {\n      await sleep(mockDelay, { signal: options?.signal });\n    }\n    \n    // Simulate random failures if configured\n    if (mockFailures && Math.random() < 0.2) {\n      await fs.writeFile(\n        path.join(workingDirectory, 'mock-failure.md'),\n        `# Mock Failure\\n\\nSimulated failure for testing purposes.\\n\\nTask: ${task.description}`,\n        'utf-8'\n      );\n      \n      return {\n        success: false,\n        artifacts: ['mock-failure.md'],\n        error: new Error('Simulated worker failure')\n      };\n    }\n    \n    try {\n      // Parse task description to determine what files to create\n      const description = task.description.toLowerCase();\n      const artifacts: string[] = [];\n      \n      // Create README.md with task description\n      const readmePath = path.join(workingDirectory, 'README.md');\n      await fs.writeFile(\n        readmePath,\n        `# Task Execution\\n\\n${task.description}\\n\\nCompleted at: ${new Date().toISOString()}`,\n        'utf-8'\n      );\n      artifacts.push('README.md');\n      \n      // Create additional files based on task description keywords\n      if (description.includes('javascript') || description.includes('js')) {\n        const jsPath = path.join(workingDirectory, 'index.js');\n        await fs.writeFile(\n          jsPath,\n          `// Generated for task: ${task.description}\\n\\nconsole.log('Task completed');`,\n          'utf-8'\n        );\n        artifacts.push('index.js');\n      }\n      \n      if (description.includes('typescript') || description.includes('ts')) {\n        const tsPath = path.join(workingDirectory, 'index.ts');\n        await fs.writeFile(\n          tsPath,\n          `// Generated for task: ${task.description}\\n\\nconst message: string = 'Task completed';\\nconsole.log(message);`,\n          'utf-8'\n        );\n        artifacts.push('index.ts');\n      }\n      \n      if (description.includes('html')) {\n        const htmlPath = path.join(workingDirectory, 'index.html');\n        await fs.writeFile(\n          htmlPath,\n          `<!DOCTYPE html>\\n<html>\\n<head>\\n  <title>Task Result</title>\\n</head>\\n<body>\\n  <h1>Task Completed</h1>\\n  <p>${task.description}</p>\\n</body>\\n</html>`,\n          'utf-8'\n        );\n        artifacts.push('index.html');\n      }\n      \n      // Always create a completion marker file\n      const completionPath = path.join(workingDirectory, 'task-completed.json');\n      await fs.writeFile(\n        completionPath,\n        JSON.stringify({\n          task: task.description,\n          completedAt: new Date().toISOString(),\n          artifacts\n        }, null, 2),\n        'utf-8'\n      );\n      artifacts.push('task-completed.json');\n      \n      return {\n        success: true,\n        artifacts\n      };\n    } catch (error: any) {\n      console.error('FileSystem worker failed:', error);\n      \n      // Create error file\n      await fs.writeFile(\n        path.join(workingDirectory, 'fs-error.md'),\n        `# Task Execution Failed\\n\\nError: ${error.message}\\n\\nTask: ${task.description}`,\n        'utf-8'\n      );\n      \n      return {\n        success: false,\n        artifacts: ['fs-error.md'],\n        error\n      };\n    }\n  };\n};\n```",
      "testStrategy": "Write unit tests for the FileSystem worker mock:\n1. Test successful task execution with various task descriptions\n2. Test simulated failures with mockFailures=true\n3. Test file creation based on task description keywords\n4. Test abort signal handling during execution\n5. Verify artifact collection matches created files",
      "priority": "medium",
      "dependencies": [2, 4],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 9,
      "title": "Implement StatefulLoop Factory Functions",
      "description": "Create factory functions that integrate all components with the statefulLoop architecture.",
      "details": "First, create `src/stateful/base-stateful.ts` with common dependencies:\n\n```typescript\nimport { BaseWorkerConfig } from '../core/types';\nimport { createStructuredLogger } from '../core/logging';\nimport { createGitDeps } from '../core/git-operations';\nimport { sleep } from '../utils/sleep';\n\nexport const createBaseStatefulLoopDeps = (config: BaseWorkerConfig) => ({\n  log: createStructuredLogger(config.logLevel || 'info'),\n  sleep: (ms: number, options?: { signal?: AbortSignal }) => sleep(ms, options),\n  git: createGitDeps(config.git || {}, config.workingDirectory)\n});\n```\n\nThen create `src/stateful/goose-stateful.ts` for production use:\n\n```typescript\nimport { TasksMachine } from '@taiga-task-master/core';\nimport { statefulLoop } from '@taiga-task-master/worker-interface';\nimport { GooseWorkerConfig } from '../core/types';\nimport { createBaseStatefulLoopDeps } from './base-stateful';\nimport { makeGooseWorker } from '../workers/goose';\nimport { createNextTaskStrategies } from '../core/next-task';\nimport { createTaskDescriptionFunctions } from '../core/task-description';\n\nexport const createGooseStatefulLoop = (config: GooseWorkerConfig) => {\n  const deps = {\n    ...createBaseStatefulLoopDeps(config),\n    runWorker: makeGooseWorker(config),\n    next: createNextTaskStrategies().priority,\n    description: createTaskDescriptionFunctions().instructions\n  };\n  \n  return (initialState: TasksMachine.State, save: (s: TasksMachine.State) => Promise<void>) => \n    statefulLoop(deps)(initialState, save);\n};\n```\n\nFinally, create `src/stateful/testing-stateful.ts` for testing:\n\n```typescript\nimport { TasksMachine } from '@taiga-task-master/core';\nimport { statefulLoop } from '@taiga-task-master/worker-interface';\nimport { TestingWorkerConfig } from '../core/types';\nimport { createBaseStatefulLoopDeps } from './base-stateful';\nimport { makeFileSystemWorker } from '../testing/filesystem-mock';\nimport { createNextTaskStrategies } from '../core/next-task';\nimport { createTaskDescriptionFunctions } from '../core/task-description';\n\nexport const createTestingStatefulLoop = (config: TestingWorkerConfig) => {\n  const deps = {\n    ...createBaseStatefulLoopDeps(config),\n    runWorker: makeFileSystemWorker(config),\n    next: createNextTaskStrategies().fifo,\n    description: createTaskDescriptionFunctions().simple\n  };\n  \n  return (initialState: TasksMachine.State, save: (s: TasksMachine.State) => Promise<void>) => \n    statefulLoop(deps)(initialState, save);\n};\n```",
      "testStrategy": "Write integration tests for the StatefulLoop factories:\n1. Test Goose StatefulLoop with mock worker and state persistence\n2. Test Testing StatefulLoop with filesystem worker\n3. Test task execution flow from initial state to completion\n4. Test error handling and recovery mechanisms\n5. Verify state transitions during task execution",
      "priority": "high",
      "dependencies": [2, 3, 4, 5, 6, 7, 8],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 10,
      "title": "Create Package Entry Point and Documentation",
      "description": "Implement the main package exports and create comprehensive documentation.",
      "details": "Create `src/index.ts` with the main exports:\n\n```typescript\n// Core types and interfaces\nexport * from './core/types';\n\n// Core utilities\nexport { createGitDeps } from './core/git-operations';\nexport { createStructuredLogger } from './core/logging';\nexport { createNextTaskStrategies } from './core/next-task';\nexport { createTaskDescriptionFunctions } from './core/task-description';\n\n// Workers\nexport { makeGooseWorker } from './workers/goose';\n\n// StatefulLoop factories\nexport { createBaseStatefulLoopDeps } from './stateful/base-stateful';\nexport { createGooseStatefulLoop } from './stateful/goose-stateful';\n\n// Testing utilities (exported for testing only)\nexport { makeFileSystemWorker } from './testing/filesystem-mock';\nexport { createTestingStatefulLoop } from './stateful/testing-stateful';\n```\n\nCreate comprehensive README.md:\n\n```markdown\n# Worker Package\n\nA reusable worker implementation for the Task Master Machine that processes tasks using AI agents (Goose AI) and Git workflows.\n\n## Installation\n\n```bash\nnpm install @taiga-task-master/worker\n```\n\n## Usage\n\n### Creating a Goose AI Worker Loop\n\n```typescript\nimport { createGooseStatefulLoop } from '@taiga-task-master/worker';\nimport { TasksMachine } from '@taiga-task-master/core';\n\n// Create initial state\nconst initialState: TasksMachine.State = {\n  tasks: TasksMachine.Tasks.empty,\n  taskExecutionState: { step: 'stopped' },\n  outputTasks: [],\n  artifacts: [],\n  timestamp: Date.now()\n};\n\n// Configure the worker\nconst createLoop = createGooseStatefulLoop({\n  workingDirectory: '/path/to/work',\n  goose: {\n    model: 'anthropic/claude-sonnet-4',\n    provider: 'openrouter'\n  },\n  apiKeys: {\n    openrouter: process.env.OPENROUTER_API_KEY\n  },\n  logLevel: 'info',\n  timeouts: {\n    process: 30000,\n    hard: 35000\n  }\n});\n\n// Create the stateful loop with state persistence\nconst machine = createLoop(initialState, async (state) => {\n  // Save state to database or file\n  await saveStateToDatabase(state);\n});\n\n// Add tasks dynamically\nconst newTasks = TasksMachine.Tasks.fromIterable([\n  ['task1', { description: 'Implement login form' }],\n  ['task2', { description: 'Add form validation' }]\n]);\n\nmachine.appendTasks(newTasks);\n\n// Stop the machine when done\nsetTimeout(() => machine.stop(), 60000);\n```\n\n## API Reference\n\n### StatefulLoop Factories\n\n#### `createGooseStatefulLoop(config: GooseWorkerConfig)`\n\nCreates a stateful loop that uses Goose AI to process tasks.\n\n**Parameters:**\n- `config`: Configuration object for the Goose worker\n\n**Returns:**\nA function that takes initial state and save function and returns a stateful loop interface.\n\n### Worker Implementations\n\n#### `makeGooseWorker(config: GooseWorkerConfig)`\n\nCreates a worker function that executes tasks using Goose AI.\n\n**Parameters:**\n- `config`: Configuration object for the Goose worker\n\n**Returns:**\nA worker function that takes a task and returns a promise of WorkerResult.\n\n### Core Utilities\n\n#### `createGitDeps(config: GitConfig, workingDirectory: string)`\n\nCreates Git operations dependencies for the worker.\n\n#### `createStructuredLogger(level: 'debug' | 'info' | 'warn' | 'error')`\n\nCreates a structured logger with the specified log level.\n\n#### `createNextTaskStrategies()`\n\nCreates task selection strategies (fifo, priority, dependencies).\n\n#### `createTaskDescriptionFunctions()`\n\nCreates functions to convert tasks to string descriptions.\n\n## Testing Utilities\n\n### `createTestingStatefulLoop(config: TestingWorkerConfig)`\n\nCreates a stateful loop for testing with a filesystem-based worker mock.\n\n### `makeFileSystemWorker(config: TestingWorkerConfig)`\n\nCreates a filesystem-based worker mock for testing.\n\n## Configuration\n\n### GooseWorkerConfig\n\n```typescript\ninterface GooseWorkerConfig {\n  workingDirectory: string;\n  logLevel?: 'debug' | 'info' | 'warn' | 'error';\n  goose: {\n    model: string;\n    provider: string;\n    instructionsFile?: string;\n  };\n  apiKeys?: {\n    openrouter?: string;\n  };\n  timeouts?: {\n    process?: number;\n    hard?: number;\n  };\n  git?: {\n    userConfig?: { name: string; email: string };\n    isolation?: boolean;\n  };\n}\n```\n\n## License\n\nMIT\n```",
      "testStrategy": "Verify package exports work correctly:\n1. Test importing all exported components\n2. Verify TypeScript types are correctly exported\n3. Test README examples for correctness\n4. Ensure documentation matches actual implementation\n5. Verify package can be installed and used in a test project",
      "priority": "medium",
      "dependencies": [1, 2, 3, 4, 5, 6, 7, 8, 9],
      "status": "pending",
      "subtasks": []
    }
  ]
}
