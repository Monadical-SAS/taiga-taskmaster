# Task ID: 2
# Title: Extract Core Types and Interfaces
# Status: pending
# Dependencies: 1
# Priority: high
# Description: Define and extract common types and interfaces needed across the worker package implementation.
# Details:
Create `src/core/types.ts` with the following:

```typescript
import { TasksMachine } from '@taiga-task-master/core';
import { NonEmptyString } from '@taiga-task-master/worker-interface';
import { Option } from 'effect';

// Task ID and Task from core package
export type { TaskId, Task } from '@taiga-task-master/core';
export type { Tasks } from '@taiga-task-master/core';

// Worker result type
export type WorkerResult = {
  success: boolean;
  artifacts?: string[];
  error?: Error;
};

// Next task function type
export type NextTaskF = (tasks: TasksMachine.Tasks) => Option<[TasksMachine.TaskId, TasksMachine.Task]>;

// Git operations interface
export interface GitOperations {
  isClean(): Promise<boolean>;
  branch(name: NonEmptyString): Promise<NonEmptyString>;
  commitAndPush(): Promise<void>;
  cleanup(previousBranch: NonEmptyString): Promise<void>;
  verifyBranchChain?(): Promise<any>;
  dumpFullState?(label: string): Promise<void>;
}

// Logger interface
export interface Logger {
  debug(message: string, ...args: any[]): void;
  info(message: string, ...args: any[]): void;
  warn(message: string, ...args: any[]): void;
  error(message: string, ...args: any[]): void;
}

// Configuration interfaces
export interface BaseWorkerConfig {
  workingDirectory: string;
  logLevel?: 'debug' | 'info' | 'warn' | 'error';
  git?: {
    userConfig?: { name: string; email: string };
    isolation?: boolean;
  };
  timeouts?: {
    process?: number;
    hard?: number;
  };
}

export interface GooseWorkerConfig extends BaseWorkerConfig {
  goose: {
    model: string;
    provider: string;
    instructionsFile?: string;
  };
  apiKeys?: {
    openrouter?: string;
  };
}

export interface TestingWorkerConfig extends BaseWorkerConfig {
  mockFailures?: boolean;
  mockDelay?: number;
}
```

# Test Strategy:
Write unit tests to verify type definitions are correct and compatible with the worker-interface and core packages. Test type compatibility by creating mock objects that implement these interfaces.
